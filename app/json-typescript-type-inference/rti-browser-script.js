"use strict";(()=>{var M=Object.defineProperty;var R=(e,t)=>{for(var i in t)M(e,i,{get:t[i],enumerable:!0})};var E={};R(E,{create_report_message:()=>re,delay_sample_point:()=>ue,delay_sample_value:()=>ee,forget:()=>se,infer_concrete_type:()=>Z,report:()=>le,sample_point:()=>te,sample_value:()=>A,sampled_values:()=>m,turn_type_into_typescript:()=>$});function y(e,t=""){if(!e)throw t==null||typeof t=="boolean"||typeof t=="number"||typeof t=="string"?new Error(`Assertion failed: ${t}`):typeof t=="function"?(t(),new Error("Assertion failed!")):(console.error("Assertion failed:",t),new Error("Assertion failed!"))}function N(e){if(e==null)throw new Error(`Unwrapping violation, value was: ${e}`);return e}function W(e){throw new Error("Exhaustive check violated!")}function q(){throw new Error("Unreachable!")}var m=new Map,I=(()=>{let e=/^[_$A-Za-z]([_$A-Za-z0-9])*$/;function t(i){return i.match(e)!==null}return t})();function B(e=""){throw new Error(`Need to implement: ${e}`)}function x(e){if(e.type==="undefined")return 10;if(e.type==="null")return 20;if(e.type==="undetermined")return 30;if(e.type==="boolean")return 40;if(e.type==="number")return 50;if(e.type==="string")return 60;if(e.type==="selfref")return 70;if(e.type==="function")return 80;if(e.type==="tuple")return 90;if(e.type==="array")return 100;if(e.type==="objectunknown")return 110;if(e.type==="object")return 120;if(e.type==="builder")return 130;if(e.type==="intersection")return 140;if(e.type==="union")return 150;W(e)}function k(){return{type:"undetermined"}}function J(){return{type:"selfref"}}function T(){return{type:"undefined"}}function P(){return{type:"null"}}function D(){return{type:"boolean"}}function G(){return{type:"number"}}function H(){return{type:"string"}}function d(e){let t=[];{let s=function(p){if(p.type==="union")for(let l of p.value)s(l);else["undetermined","selfref","undefined","null","boolean","number","string","objectunknown"].includes(p.type)?r.has(p.type)||(r.add(p.type),t.push(p)):t.push(p)};var i=s;let r=new Set;for(let p of e)s(p)}{let r=[],s=[],p=[];for(let u=0;u<t.length;u++){let f=t[u];f.type==="tuple"?f.strict?s.push(f):p.push(f):r.push(f)}let l=[];if(s.length>0){let u=s[0];y(u.strict===!0);for(let f=1;f<s.length;f++){let n=s[f];if(y(n.strict===!0),u.value.length===n.value.length)for(let o=0;o<u.value.length;o++){let a=h(u.value[o],n.value[o]);u.value[o]=a}else{let o,a;u.value.length<n.value.length?(o=u,a=n):(o=n,a=u),y(o.value.length<a.value.length,`Tuple a was expected to be larger than tuple b: ${o.value.length} vs ${a.value.length}`),y(o.strict===!0),y(a.strict===!0);let c=[];for(let g=0;g<o.value.length;g++)c.push(h(o.value[g],a.value[g]));for(let g=o.value.length;g<a.value.length;g++)c.push(h(T(),a.value[g]));let _=V(c,!0);y(_.strict===!0),u=_}}y(u.type==="tuple"),y(u.strict===!0),l.push(u)}if(p.length>0){let u=p[0];y(u.strict===!1);for(let f=1;f<p.length;f++){let n=p[f];if(y(n.strict===!1),u.type==="tuple")if(u.value.length===n.value.length){for(let o=0;o<u.value.length;o++){let a=h(u.value[o],n.value[o]);u.value[o]=a}return u}else{let o=[];y(u.strict===!1),y(n.strict===!1);for(let c of u.value)o.push(c);for(let c of n.value)o.push(c);y(o.length>0);let a=o[0];for(let c=1;c<o.length;c++)a=h(a,o[c]);u=b(a)}else if(n.value.length>0){let o=[];for(let c of n.value)o.push(c);let a=u.value;for(let c=0;c<o.length;c++)a=h(a,o[c]);u.value=a}}l.push(u)}t=[...r,...l]}{let r=[],s=[];for(let l=0;l<t.length;l++){let u=t[l];u.type==="tuple"?u.strict?r.push(u):s.push(u):u.type==="array"?s.push(u):r.push(u)}let p=[];if(s.length>0){let l=s[0];for(let u=1;u<s.length;u++){let f=s[u];if(l.type==="tuple"){if(y(!l.strict),f.type==="tuple")if(y(!f.strict),l.value.length===f.value.length)for(let n=0;n<l.value.length;n++)l.value[n]=h(l.value[n],f.value[n]);else{let n=[];for(let a of l.value)n.push(a);for(let a of f.value)n.push(a);y(n.length>0);let o=n[0];for(let a=1;a<n.length;a++)o=h(o,n[a]);l=b(o)}else if(f.type==="array")if(l.value.length>0){let n=f.value;for(let o=0;o<l.value.length;o++)n=h(n,l.value[o]);f.value=n,l=f}else l=f}else if(l.type==="array")if(f.type==="tuple"){if(y(!f.strict),f.value.length>0){let n=l.value;for(let o=0;o<f.value.length;o++)n=h(n,f.value[o]);l.value=n}}else f.type==="array"&&(l.value=h(l.value,f.value))}p.push(l)}t=[...r,...p]}{let r=[],s=[];for(let l of t)l.type==="object"?r.push(l):s.push(l);let p=[];if(r.length>0){let l=r[0];for(let u=1;u<r.length;u++)l=h(l,r[u]);p.push(l)}t=[...s,...p]}{let r=[],s=new Map,p=new Set;for(let u of t)u.type==="builder"?s.has(u.value)||s.set(u.value,u):(u.type==="intersection"&&p.add(u.value[0].value),r.push(u));for(let u of p)s.delete(u);let l=[...s.values()];t=[...r,...l]}{let r=[],s=[];for(let u of t)u.type==="intersection"?r.push(u):s.push(u);r.sort((u,f)=>u.value[0].value.localeCompare(f.value[0].value));let p=[],l=new Map;for(let u of r){let f=u.value[0].value;l.hasOwnProperty(f)||l.set(f,[]),N(l.get(f)).push(u)}for(let u of l.values()){y(u.length>0);let f=u[0];for(let n=1;n<u.length;n++){let o=u[n];y(f.value[0].value===o.value[0].value);let a=h(f,o);y(a.type==="intersection"),f=a}p.push(f)}t=[...s,...p]}{let r=[],s=[];for(let l of t)l.type==="function"?r.push(l):s.push(l);r.sort((l,u)=>l.number_of_arguments-u.number_of_arguments);let p=[];{let l=null;for(let u=0;u<r.length;u++){let f=r[u];l===null?l=f:l.number_of_arguments!==f.number_of_arguments&&(p.push(l),l=f)}l!==null&&(p.push(l),l=null)}t=[...s,...p]}if(y(t.length>=1),t.sort((r,s)=>{let p=x(r),l=x(s);return p-l}),t.length===1){let r=t[0];return y(r.hasOwnProperty("type")),r}else return{type:"union",value:t}}function K(e){return y(e.length===2),y(e[0].type==="builder"),{type:"intersection",value:e}}function V(e,t=!1){return{type:"tuple",value:e,strict:t}}function b(e){return{type:"array",value:e}}function O(e){let t={};for(let i of e){let[r,s]=i;t[r]=s}return{type:"object",value:t}}function L(){return{type:"objectunknown"}}function S(e,t){let i=[];for(let r=0;r<e;r++)i.push(`p${r+1}`);if(t!==void 0)for(let r=0;r<t.length;r++)i[r]=t[r];return{type:"function",number_of_arguments:e,parameter_names:i}}function j(e){return{type:"builder",value:e}}var Q=/^[A-Z]/,X=/\((?<params>\s*\w+(,\s*\w+)*)\)/;function Y(e){return e===null?!1:typeof e=="object"?!0:typeof e=="function"}function U(e){let i=(""+e).match(X);if(i!==null){let r=i.groups;if(r!==void 0){let s=r.params;return typeof s!="string"?void 0:s.split(",").map(l=>l.trim())}else return}else return}function Z(e,t){let i=[];function r(p,l,u){let f=Y(p);if(f){if(i.includes(p))return J();i.push(p)}let n;if(p===void 0)n=T();else if(p===null)n=P();else if(typeof p=="boolean")n=D();else if(typeof p=="number")n=G();else if(typeof p=="string")n=H();else if(Object.prototype.toString.call(p)==="[object Arguments]"){if(l>=u)return f&&i.pop(),b(k());let o=[];for(let a=0;a<p.length;a++){let c=p[a];o.push(r(c,l+1,u))}n=V(o,!0)}else if(Array.isArray(p)){if(l>=u)return f&&i.pop(),b(k());if(t&&t.experimentalInterpretArrayAsArray)if(p.length===0)n=b(k());else{let o=[];for(let c of p)o.push(r(c,l+1,u));let a=o[0];for(let c=1;c<o.length;c++)a=h(a,o[c]);n=b(a)}else{let o=[];for(let a of p)o.push(r(a,l+1,u));n=V(o,!1)}}else if(typeof p=="function")if(p.name)if(p.name.match(Q)!==null)n=j(p.name);else{let o=U(p);n=S(p.length,o)}else{let o=U(p);n=S(p.length,o)}else{let o="";if(p&&p.constructor&&(o=p.constructor.name),l>=u)return f&&i.pop(),o==="Object"?L():j(o);if(["Object"].includes(o)){let a=Object.keys(p);a.sort();let c=[];for(let _ of a){let g=p[_],w=r(g,l+1,u);c.push([_,w])}n=O(c)}else{let a=Object.keys(p);a.sort();let c=[];for(let g of a){let w=p[g],C=r(w,l+1,l+1);c.push([g,C])}let _=O(c);o.length>0&&o!=="Object"&&(_=K([j(o),_])),n=_}}return f&&i.pop(),n}let s=r(e,0,1/0);return y(i.length===0,"We didn't pop off all the values off of the circular reference detector stack."),y(s!==void 0,"We expected to get some concrete type, not undefined."),y(s!==null,"We expected to get some concrete type, not null."),s}function h(e,t){if(e.type==="undefined")return t.type==="undefined"?e:d([e,t]);if(e.type==="undetermined")return t.type==="undetermined"?e:t;if(e.type==="null")return t.type==="null"?e:d([e,t]);if(e.type==="boolean")return t.type==="boolean"?e:d([e,t]);if(e.type==="number")return t.type==="number"?e:d([e,t]);if(e.type==="string")return t.type==="string"?e:d([e,t]);if(e.type==="selfref")return t.type==="selfref"?e:d([e,t]);if(e.type==="union")return d([e,t]);if(e.type==="tuple")if(t.type==="tuple")if(e.strict&&t.strict)if(e.value.length===t.value.length){for(let i=0;i<e.value.length;i++)e.value[i]=h(e.value[i],t.value[i]);return y(e.strict===!0),e}else{let i,r;e.value.length<t.value.length?(i=e,r=t):(i=t,r=e),y(i.value.length<r.value.length,`Tuple a was expected to be larger than tuple b: ${i.value.length} vs ${r.value.length}`);let s=[];for(let l=0;l<i.value.length;l++)s.push(h(i.value[l],r.value[l]));for(let l=i.value.length;l<r.value.length;l++)s.push(h(T(),r.value[l]));let p=V(s,!0);return y(p.strict===!0),p}else{if(e.strict||t.strict)return y(e.strict&&!t.strict||!e.strict&&t.strict),d([e,t]);if(y(!e.strict),y(!t.strict),e.value.length===t.value.length){for(let i=0;i<e.value.length;i++)e.value[i]=h(e.value[i],t.value[i]);return y(!e.strict),e}else{let i=[];for(let s of e.value)i.push(s);for(let s of t.value)i.push(s);y(i.length>0);let r=i[0];for(let s=1;s<i.length;s++)r=h(r,i[s]);return b(r)}}else if(t.type==="array"){if(e.strict)return y(e.strict===!0),d([e,t]);{if(e.value.length===0)return t;let i=[];for(let s of e.value)i.push(s);let r=t.value;for(let s=0;s<i.length;s++)r=h(r,i[s]);return t.value=r,t}}else return d([e,t]);else if(e.type==="array"){if(t.type==="array")return e.value=h(e.value,t.value),e;if(t.type==="tuple"){if(t.strict)return d([e,t]);{if(t.value.length===0)return e;let i=[];for(let s of t.value)i.push(s);let r=e.value;for(let s=0;s<i.length;s++)r=h(r,i[s]);return e.value=r,e}}else return d([e,t])}else if(e.type==="object")if(t.type==="object"){let i=new Set(Object.keys(e.value)),r=new Set(Object.keys(t.value)),s=new Set;for(let u of i)r.has(u)&&(s.add(u),i.delete(u),r.delete(u));let p=[];for(let u of s)p.push([u,h(e.value[u],t.value[u])]);for(let u of i)p.push([u,d([T(),e.value[u]])]);for(let u of r)p.push([u,d([T(),t.value[u]])]);return p.sort((u,f)=>u[0].localeCompare(f[0])),O(p)}else return d([e,t]);else{if(e.type==="objectunknown")return t.type==="objectunknown"?e:d([e,t]);if(e.type==="builder")return t.type==="builder"&&t.value===e.value?e:d([e,t]);if(e.type==="intersection")if(t.type==="intersection")if(y(e.value[0].type==="builder"),y(e.value[1].type!=="builder"),y(t.value[0].type==="builder"),y(t.value[1].type!=="builder"),e.value[0].value===t.value[0].value){let i=h(e.value[1],t.value[1]);return e.value[1]=i,e}else return d([e,t]);else return d([e,t]);else{if(e.type==="function")return t.type==="function"?e.number_of_arguments===t.number_of_arguments?e:d([e,t]):d([e,t]);console.log(e.type),B("combine_type: unhandled type: "+e.type)}}q()}function A(e,t,i){let r=Z(t,i);y(r!==null&&typeof r=="object");let s;if(m.has(e)){let p=N(m.get(e));p=h(p,r),y(p!==null&&typeof p=="object"),s=p,m.set(e,p)}else m.set(e,r),s=r;return y(s!==void 0),y(s!==null&&typeof s=="object"),s}function ee(e,t,i){v.push({name:e,value:t,inference_options:i})}var ne=(()=>{let e=/\d+:\d+$/,t=/([A-Za-z]([A-Za-z0-9+.-])*:\/\/.+?:\d+:\d+)/,i=/(<anonymous>:\d+:\d+)/,r=/([A-Za-z]([A-Za-z0-9+.-])*:\\.+?:\d+\d+)/,s=/(.+\/)*.+:\d+:\d+/,p=/([A-Za-z]([A-Za-z0-9+.-])*:\/\/.+?:\d+:\d+)$/,l=/@(?<location>debugger eval code:\d+:\d+)/;function u(f){let n=[],o=f.split(`
`).map(a=>a.trim()).filter(a=>a.length>0);if(o.length===0)return n;if(["Error","Error:"].includes(o[0])){o.shift(),o=o.map(a=>a.substring(3));for(let a of o)if(a[a.length-1]===")"){let c=a.indexOf("("),_=a.lastIndexOf(")");if(a=a.substring(c+1,_),a.match(e)){n.push(a);continue}else{n.push(null);continue}}else{let c;if(c=a.match(t),c!==null){n.push(c[0]);continue}if(c=a.match(i),c!==null){n.push(c[0]);continue}if(c=a.match(r),c!==null){n.push(c[0]);continue}if(c=a.match(s),c!==null){n.push(c[0]);continue}throw console.log(`Stack:
`+f),new Error("Unable to handle: ["+a+"]")}}else for(let a of o){let c;if(c=a.match(p),c!==null){n.push(c[0]);continue}if(c=a.match(l),c!==null){y(c.groups!==void 0),y(typeof c.groups.location=="string"),n.push(c.groups.location);continue}throw console.log(`Stack:
`+f),new Error("Unable to handle: ["+a+"]")}return n}return u})();function z(e){let i=new Error().stack;if(i===void 0)throw new Error("Error stack may not be undefined.");let s=ne(i)[e];return y(s!==void 0),y(s!==null),s}var v=[];function te(e,t){let i=z(2);return A(i,e,t)}function ue(e,t){let i=z(2);v.push({name:i,value:e,inference_options:t})}function F(){let e=v.length;for(let t=0;t<e;t++){let i=v[t],{name:r,value:s,inference_options:p}=i;A(r,s,p)}for(;v.length>0;)v.pop()}function $(e,t){let i="  ",r=!0;t!==void 0&&(t.ident!==void 0&&(i=t.ident),t.fmt!==void 0&&(r=t.fmt));function s(l,u,f){y(e!=null);let n=[];if(u.type==="undefined")n.push("undefined");else if(u.type==="undetermined")n.push("unknown");else if(u.type==="null")n.push("null");else if(u.type==="boolean")n.push("boolean");else if(u.type==="number")n.push("number");else if(u.type==="string")n.push("string");else if(u.type==="selfref")n.push('"<self-reference/>"');else if(u.type==="builder")n.push(u.value);else if(u.type==="tuple")if(u.value.length===0)n.push("[]");else if(u.value.length===1)n.push("["),n.push(s(l,u.value[0],!1)),n.push("]");else{if(n.push("["),r&&n.push(`
`),u.value.length>0){for(let o of u.value)r&&n.push(i.repeat(l+1)),n.push(s(l+1,o,!1)),n.push(","),r&&n.push(`
`);r&&n.pop(),n.pop(),r&&n.push(`
`)}r&&n.push(i.repeat(l)),n.push("]")}else if(u.type==="array"){let o=u.value.type==="union"||u.value.type==="intersection";o&&n.push("("),n.push(s(l+1,u.value,!1)),o&&n.push(")"),n.push("[]")}else if(u.type==="object"){let o=Object.keys(u.value);if(o.sort(),o.length===0)n.push("{}");else if(o.length===1){n.push("{"),r&&n.push(" ");for(let a of o){let c=u.value[a];I(a)?n.push(a):n.push(JSON.stringify(a)),n.push(":"),r&&n.push(" "),n.push(s(l+1,c,!1)),n.push(","),r&&n.push(" ")}r&&n.pop(),n.pop(),r&&n.push(" "),n.push("}")}else{n.push("{"),r&&n.push(`
`);for(let a of o){let c=u.value[a];r&&n.push(i.repeat(l+1)),I(a)?n.push(a):n.push(JSON.stringify(a)),n.push(":"),r&&n.push(" "),n.push(s(l+1,c,!1)),n.push(","),r&&n.push(`
`)}r&&n.pop(),n.pop(),r&&n.push(`
`),r&&n.push(i.repeat(l)),n.push("}")}}else if(u.type==="objectunknown")r?n.push("{ [key: string]: unknown }"):n.push("{[key:string]:unknown}");else if(u.type==="union"){for(let o of u.value)n.push(s(l,o,!0)),r&&n.push(" "),n.push("|"),r&&n.push(" ");r&&n.pop(),n.pop(),r&&n.pop()}else if(u.type==="function"){let o=u.number_of_arguments;if(f&&n.push("("),n.push("("),o>0){for(let a of u.parameter_names)n.push(`${a}: unknown`),n.push(","),r&&n.push(" ");r&&n.pop(),n.pop()}n.push(")"),r&&n.push(" "),n.push("=>"),r&&n.push(" "),n.push("unknown"),f&&n.push(")")}else if(u.type==="intersection"){let o=u.value[0],a=u.value[1];a.type==="object"&&Object.keys(a.value).length===0?n.push(s(l,o,!0)):(n.push(s(l,o,!0)),r&&n.push(" "),n.push("&"),r&&n.push(" "),n.push(s(l,a,!0)))}else console.log("(turn_type_into_typescript) Unknown type value:",u),B(`(turn_type_into_typescript) Need to implement type value type: ${u.type}`);return n.join("")}return s(0,e,!1)}function re(){F();let e=[],t=0;for(let r of m.entries()){let s=r[0],p=r[1];e.push("// "+s+`:
`),e.push(`type T${t} = `),e.push($(p)+`;
`),e.push(`
`),t+=1}return e.length>0&&e.pop(),e.join("")}function le(e=!1){F(),e&&console.clear();let t=0;for(let i of m.entries()){let r=i[0],s=i[1],p=[];p.push("// "+r+`
`),p.push(`type T${t} = `),p.push($(s)+`;
`),p.push(`
`),console.log(p.join("")),t+=1}}function se(){m.clear()}globalThis.rti=E;})();
