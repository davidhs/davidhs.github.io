{"version":3,"sources":["api/Dictionary.ts","api/lib.ts","api/StorageMap.ts","api/localStorageMap.ts","api/KeyPrefixedMap.ts","api/Library.ts","api/index.ts","components/button/Button.tsx","components/search-result/SearchResult.tsx","components/search-results/SearchResults.tsx","components/input-search/InputSearch.tsx","components/import-button/ImportButton.tsx","components/export-button/ExportButton.tsx","components/confirmation-button/ConfirmationButton.tsx","components/input-text/InputText.tsx","routes/home/Home.tsx","routes/system-pages/NotFound.tsx","App.tsx","index.tsx"],"names":["Dictionary","map","this","term","get","description","set","delete","clear","assert","condition","message","Error","Symbol","toStringTag","iterator","StorageMap","storage","key","item","getItem","undefined","value","setItem","removeItem","i","length","done","callbackfn","thisArg","bind","localStorageMap","localStorage","KeyPrefixedMap","keyPrefix","Map","startsWith","unprefixedKey","substring","prefixedKey","has","keys","entries","pair","values","size","Library","localStorageNamespace","lsprefix","namespacesSet","Set","nskey","substr","colonIdx","indexOf","namespace","add","forEach","dictionary","hasDictionary","dictionaryNamespace","removeDictionary","paramQuery","paramNamespace","trim","toLowerCase","isFullsearch","query","namespaceExists","allTerms","Object","filter","lskey","namespacedKey","lspnamespace","lspkey","namespaceList","Array","from","sort","escapedQuery","replace","a","b","localeCompare","terms","namespaces","startsWithRegex","RegExp","notStartsHasRegex","hasRegex","markedTerms","termsStartingWithQuery","fullkey","match","termsWithMatchingTerms","termsWithMatchingDescription","v","legacy_get","termsAdditionalInFullsearch","remove","createDictionary","legacy_set","LOCAL_STORAGE_NAMESPACE","dictionaries","hasOwnProperty","exportTerm","push","exportObject","subdictionary","importObject","termObject","library","window","Button","state","onClick","classes","props","disabled","className","Boolean","join","setState","children","style","React","Component","SearchResult","handleClick","onSelection","width","borderTop","borderLeft","borderRight","SearchResults","idx","defaultAutocomplete","e","suggestions","topSuggestion","preventDefault","InputSearch","handleOnChangeSearchValue","searchValue","target","setSearchValue","handleOnClickClear","handleOnKeyDownSearchValue","autocomplete","autocompleteValue","onChange","spellCheck","type","onKeyDown","border","ImportButton","inputElement","click","handleFileChange","onImport","reader","FileReader","onload","e2","text","result","files","readAsText","Fragment","ref","input","ExportButton","anchor","getContent","filename","content","uriEncodedString","encodeURIComponent","data","href","download","display","ConfirmationButton","exteriorOnClick","confirmationMessage","confirm","InputText","placeholder","leftpad","str","pad","String","slice","Home","resultText","placeholderText","flattenedTerms","includes","resolveSearch","index","originalSearchValue","handleOnChangeTextArea","setTermDescription","handleOnSelection","setNamespace","handleOnImport","api","legacy_doImport","JSON","parse","updateTerms","handleOnClearEverything","removeEverything","handleGetContent","stringify","legacy_doExport","handleOnChangeNamespace","lookupValue","derivedNamespace","derived","space1","space2","space3","space4","leftPart","rightPart","idx1","idx2","idx3","idx4","repeat","legacy_searchTermsAndDescriptions","didNotExistBefore","title","legacy_remove","originalTitle","trimLeft","listedTerms","ds","d","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getDateNowString","ns","borderBottom","rows","cols","backgroundColor","color","borderColor","NotFound","withRouter","defaultTitle","location","path","exact","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.15745256.chunk.js","sourcesContent":["/**\n * TODO: a dictionary should not concern itself with local storage or name-\n * spaces (ideally).\n */\nexport default class Dictionary {\n  #map: Map<string, string>;\n  \n  /**\n   * The vault **must** be ready before constructing a dictionary.\n   * \n   * @param vault\n   */\n  constructor(map: Map<string, string>) {\n    this.#map = map;\n  }\n\n  /**\n   * Retrieves the description for the term, or `undefined` if the term is not\n   * defined.\n   * \n   * @param term \n   */\n  public get(term: string): string | undefined {\n    return this.#map.get(term);\n  }\n\n  /**\n   * Sets the term with the description.\n   * \n   * @param term \n   * @param description \n   */\n  public set(term: string, description: string): void {\n    this.#map.set(term, description);\n  }\n\n  /**\n   * Removes the term if exists.  If it doesn't exist then nothing happens.\n   * \n   * @param term \n   */\n  public remove(term: string): void {\n    this.#map.delete(term);\n  }\n\n  /**\n   * Removes all terms and descriptions from this dictionary.\n   */\n  public clear(): void {\n    this.#map.clear();\n  }\n}\n","/**\n * Asserts condition `condition`.\n * \n * @param condition \n * @param message \n */\nexport function assert(condition: boolean, message = \"Assertion failed\"): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n/**\n * A function to escape characters in a string so they won't be treated as\n * meta-characters in the construction of a regular expresion.\n * \n * @param str\n */\nexport function escapeRegExp(str: string) {\n  // $& means the whole matched string\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","export default class StorageMap implements Map<string, string> {\n  #storage: Storage;\n\n  constructor(storage: Storage) {\n    this.#storage = storage;\n  }\n\n  get(key: string): string | undefined {\n    const item = this.#storage.getItem(key);\n    \n    return item === null ? undefined : item;\n  }\n\n  set(key: string, value: string): this {\n    this.#storage.setItem(key, value);\n\n    return this;\n  }\n\n  has(key: string): boolean {\n    const item = this.#storage.getItem(key);\n\n    return item !== null;\n  }\n\n  delete(key: string): boolean {\n    const item = this.#storage.getItem(key);\n\n    if (item === null) return false;\n\n    this.#storage.removeItem(key);\n\n    return true;\n  }\n\n  clear(): void {\n    this.#storage.clear();\n  }\n\n  * entries(): IterableIterator<[string, string]> {\n    for (let i = 0; i < this.#storage.length; i += 1) {\n      const key = this.#storage.key(i);\n\n      if (key === null) continue;\n\n      const value = this.#storage.getItem(key);\n\n      if (value === null) continue;\n\n      yield [key, value];\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  forEach(callbackfn: (value: string, key: string, map: Map<string, string>) => void, thisArg?: any): void {\n    if (thisArg) callbackfn.bind(thisArg);\n\n    for (let i = 0; i < this.#storage.length; i += 1) {\n      const key = this.#storage.key(i);\n\n      if (key === null) continue;\n\n      const value = this.#storage.getItem(key);\n\n      if (value === null) continue;\n\n      callbackfn(value, key, this);\n    }\n  }\n\n  * keys(): IterableIterator<string> {\n    for (let i = 0; i < this.#storage.length; i += 1) {\n      const key = this.#storage.key(i);\n      \n      if (key === null) continue;\n\n      yield key;\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  * values(): IterableIterator<string> {\n    for (let i = 0; i < this.#storage.length; i += 1) {\n      const key = this.#storage.key(i);\n      \n      if (key === null) continue;\n\n      const value = this.#storage.getItem(key);\n\n      if (value === null) continue;\n\n      yield value;\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'StorageMap';\n  }\n\n  *[Symbol.iterator](): IterableIterator<[string, string]> {\n    for (let i = 0; i < this.#storage.length; i += 1) {\n      const key = this.#storage.key(i);\n\n      if (key === null) continue;\n\n      const value = this.#storage.getItem(key);\n\n      if (value === null) continue;\n\n      yield [key, value];\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  get size() {\n    return this.#storage.length;\n  }\n}\n","import StorageMap from \"./StorageMap\";\n\n\nclass LocalStorageMap extends StorageMap {\n  constructor() {\n    super(localStorage);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'LocalStorageMap';\n  }\n}\n\n\nconst localStorageMap = new LocalStorageMap();\n\nexport default localStorageMap;\n","/**\n * Assumption: this key-prefixed map is the sole owner of the key prefix and\n * nothing else in the program is messing with that key prefix.\n */\nexport default class KeyPrefixedMap<V> implements Map<string, V> {\n  #backend: Map<string, V>;\n  #cache: Map<string, V>;\n  #keyPrefix: string;\n\n  constructor(map: Map<string, V>, keyPrefix: string) {\n    this.#backend = map;\n    this.#keyPrefix = keyPrefix;\n    this.#cache = new Map();\n\n    for (const [key, value] of this.#backend) {\n      if (!key.startsWith(this.#keyPrefix)) continue;\n\n      const unprefixedKey = key.substring(this.#keyPrefix.length);\n\n      this.#cache.set(unprefixedKey, value);\n    }\n  }\n\n  get(key: string): V | undefined {\n    return this.#cache.get(key);\n  }\n\n  set(key: string, value: V): this {\n    this.#cache.set(key, value);\n\n    const prefixedKey = `${this.#keyPrefix}${key}`;\n\n    this.#backend.set(prefixedKey, value);\n\n    return this;\n  }\n\n  has(key: string): boolean {\n    return this.#cache.has(key);\n  }\n\n\n  delete(key: string): boolean {\n    if (!this.#cache.has(key)) return false;\n\n    this.#cache.delete(key);\n\n    const prefixedKey = `${this.#keyPrefix}${key}`;\n\n    this.#backend.delete(prefixedKey);\n\n    return true;\n  }\n\n  clear(): void {\n    for (const key of this.#cache.keys()) {\n      this.#cache.delete(key);\n\n      const prefixedKey = `${this.#keyPrefix}${key}`;\n\n      this.#backend.delete(prefixedKey);\n    }\n  }\n\n  * entries(): IterableIterator<[string, V]> {\n    for (const pair of this.#cache.entries()) {\n      yield pair;\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  forEach(callbackfn: (value: V, key: string, map: Map<string, V>) => void, thisArg?: any): void {\n    if (thisArg) callbackfn.bind(thisArg);\n\n    for (const [key, value] of this.entries()) {\n      callbackfn(value, key, this);\n    }\n  }\n\n  * keys(): IterableIterator<string> {\n    for (const key of this.#cache.keys()) {\n      yield key;\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  * values(): IterableIterator<V> {\n    for (const value of this.#cache.values()) {\n      yield value;\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  *[Symbol.iterator](): IterableIterator<[string, V]> {\n    for (const pair of this.#cache.entries()) {\n      yield pair;\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'KeyPrefixedMap';\n  }\n\n  get size() {\n    return this.#cache.size;\n  }\n}","import Dictionary from \"./Dictionary\";\nimport { ExportTerm, ExportObject, ExportSubdictionary, Legacy1ExportObject, ImportObject } from \"./types\";\nimport { escapeRegExp, assert } from \"./lib\";\nimport localStorageMap from \"./localStorageMap\";\nimport KeyPrefixedMap from \"./KeyPrefixedMap\";\n\n// TODO: need a much more robust name to define dictionary names.\n\n// TODO: maybe I don't want to put terms in lowercase anymore, just have a simple\n// key-value database (string)\n\nconst DEFAULT_NAMESPACE = 'default';\n\n/**\n * The purpose of this class is to be able to probe multiple dictionaries, and\n * keep track of which dictionary is in use, etc.\n * \n * \n */\nexport default class Library {\n  #dictionaries: Map<string, Dictionary>\n  #localStorageNamespace: string;\n\n  /**\n   * TODO: `Library` should NOT concern itself with that it might be using\n   * local storage as its backend, or IndexedDB, or maybe even a remote\n   * storage (SQLite, PostgreSQL).\n   * \n   * TODO: should be able to use whatever backend storage it sees fit as long \n   * as the interface for `get`, `set`, and `remove` is synchronous.\n   * \n   * TODO: supply this with storage method.\n   * \n   * @param localStorageNamespace \n   */\n  constructor(localStorageNamespace: string) {\n    this.#dictionaries = new Map();\n    this.#localStorageNamespace = localStorageNamespace;\n\n    //////////////////////////////\n    // Load in all dictionaries //\n    //////////////////////////////\n\n    {\n      const lsprefix = `${localStorageNamespace}:`;\n\n      const namespacesSet = new Set<string>();\n\n      for (const key of localStorageMap.keys()) {\n        if (!key.startsWith(lsprefix)) continue;\n\n        const nskey = key.substr(lsprefix.length);\n        const colonIdx = nskey.indexOf(':');\n        const namespace = nskey.substring(0, colonIdx);\n        namespacesSet.add(namespace);\n      }\n\n      namespacesSet.forEach((namespace) => {\n        const keyPrefix = `${localStorageNamespace}:${namespace}:`;\n\n        const map = new KeyPrefixedMap<string>(localStorageMap, keyPrefix);\n\n        const dictionary = new Dictionary(map);\n\n        this.#dictionaries.set(namespace, dictionary);\n      });\n    }\n  }\n\n  /**\n   * \n   * @param namespace \n   */\n  public hasDictionary(namespace: string): boolean {\n    return this.#dictionaries.has(namespace);\n  }\n\n  /**\n   * Creates a dictionary with the name `namespace`.  If a dictionary with the\n   * same name exists then it throws an error.\n   * \n   * @param namespace \n   * \n   * @throws\n   */\n  public createDictionary(namespace: string): void {\n    assert(!this.hasDictionary(namespace));\n\n    const keyPrefix = `${this.#localStorageNamespace}:${namespace}:`;\n    const map = new KeyPrefixedMap<string>(localStorageMap, keyPrefix);\n\n    const dictionary = new Dictionary(map);\n\n    this.#dictionaries.set(namespace, dictionary);\n  }\n\n  /**\n   * Removes as dictionary.  Nothing happens if the dictionary doesn't exist.\n   * \n   * @param namespace \n   */\n  public removeDictionary(namespace: string) {\n    const dictionary = this.#dictionaries.get(namespace);\n\n    if (!dictionary) return;\n\n    dictionary.clear();\n\n    this.#dictionaries.delete(namespace);\n  }\n\n  /**\n   * Removes every single dictionary.\n   */\n  public removeEverything() {\n    for (const dictionaryNamespace of this.#dictionaries.keys()) {\n      this.removeDictionary(dictionaryNamespace);\n    }\n  }\n\n  /**\n   * Search termsn and descriptions\n   * \n   * @param paramQuery \n   * @param paramNamespace \n   */\n  public legacy_searchTermsAndDescriptions(paramQuery: string, paramNamespace: string) {\n    // TODO: this function needs to be completely reworked!\n\n    const namespace = paramNamespace.trim().toLowerCase();\n    const isFullsearch = namespace === '*';\n    const query = paramQuery.trim().toLowerCase();\n    const lsprefix = `${this.#localStorageNamespace}:`;\n    let namespaceExists = false;\n    const namespacesSet = new Set<string>();\n\n    ///////////////////////\n    // Pick up all terms //\n    ///////////////////////\n\n    const allTerms = Object.keys(localStorage)\n      .filter(lskey => lskey.startsWith(lsprefix))\n      .map(lskey => {\n        const namespacedKey = lskey.substr(lsprefix.length);\n\n        const colonIdx = namespacedKey.indexOf(':');\n\n        const lspnamespace = namespacedKey.substring(0, colonIdx);\n        const lspkey = namespacedKey.substring(colonIdx + 1, namespacedKey.length);\n\n        if (namespace === lspnamespace) namespaceExists = true;\n\n        namespacesSet.add(lspnamespace);\n\n        return {\n          namespace: lspnamespace,\n          key: lspkey\n        }\n      }).filter(namespacedKey => {\n        if (namespaceExists) {\n          return namespacedKey.namespace === namespace;\n        } else {\n          // Let everything through\n          return true;\n        }\n      });\n\n    ////////////////////\n    // Filter terms ? //\n    ////////////////////\n\n    const namespaceList = Array.from(namespacesSet).sort();\n\n    // If the query starts with `s` and we have multiple terms that start\n    // with `s` then those terms should be on the top.\n\n    const escapedQuery = escapeRegExp(query);\n\n    allTerms.sort((a, b) => a.key.localeCompare(b.key));\n\n    if (escapedQuery.length === 0) {\n      const returnObject = {\n        terms: allTerms,\n        namespaceExists,\n        namespaces: namespaceList,\n      };\n\n      return returnObject;\n    }\n\n    const startsWithRegex = new RegExp(`^${escapedQuery}.*`);\n    const notStartsHasRegex = new RegExp(`.+${escapedQuery}.*`);\n    const hasRegex = new RegExp(`.*${escapedQuery}.*`);\n\n    // Terms that we encounter we \"mark\" them so that if they're encounted again\n    // they are ignored.\n    const markedTerms = new Set<string>();\n\n    // TODO: does this result in duplicate results?\n\n    // Terms which start with the query string\n    const termsStartingWithQuery = allTerms.filter(namespacedKey => {\n      const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n      if (markedTerms.has(fullkey)) return false;\n\n      if (namespacedKey.key.match(startsWithRegex) !== null) {\n        markedTerms.add(fullkey);\n        return true;\n      }\n\n      return false;\n    }).sort((a, b) => a.key.length - b.key.length);\n\n    // Later, we want to sort terms by similarity.\n\n    const termsWithMatchingTerms = allTerms.filter(namespacedKey => {\n      const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n      if (markedTerms.has(fullkey)) return false;\n\n      if (namespacedKey.key.match(notStartsHasRegex) !== null) {\n        markedTerms.add(fullkey);\n        return true;\n      }\n\n      return false;\n    }).sort((a, b) => a.key.length - b.key.length);\n\n    const termsWithMatchingDescription = allTerms.filter(namespacedKey => {\n      const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n      if (markedTerms.has(fullkey)) return false;\n\n      const { key, namespace } = namespacedKey;\n      const v = this.legacy_get(key, namespace);\n\n      if (typeof v !== 'undefined' && v.match(hasRegex) !== null) {\n        markedTerms.add(fullkey);\n        return true;\n      }\n\n      return false;\n    })\n\n    let termsAdditionalInFullsearch: { namespace: string, key: string }[] = [];\n\n    if (isFullsearch) {\n      termsAdditionalInFullsearch = allTerms.filter(namespacedKey => {\n\n        const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n        if (markedTerms.has(fullkey)) return false;\n\n        if (namespacedKey.namespace.startsWith(query)) {\n          markedTerms.add(fullkey);\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    // TODO: this is probably slow...\n\n    // TODO: am I duplicating terms here?\n\n    const returnObject = {\n      terms: [\n        ...termsStartingWithQuery,\n        ...termsWithMatchingTerms,\n        ...termsWithMatchingDescription,\n        ...termsAdditionalInFullsearch,\n      ],\n      namespaceExists,\n      namespaces: namespaceList,\n    };\n\n    return returnObject;\n  }\n\n  /**\n   * Removes JSON value from local storage with key `key` and namespace\n   * `namespace`.\n   * \n   * @param key \n   * @param namespace \n   */\n  public legacy_remove(term: string, namespace: string) {\n    if (!this.hasDictionary(namespace)) return;\n    \n    // TODO: this is inconvenient.\n    const dictionary = this.#dictionaries.get(namespace);\n    \n    assert(typeof dictionary !== \"undefined\");\n\n    dictionary.remove(term);\n  }\n\n  /**\n   * Sets JSON value in local storage with key `key` and namespace `namespace`.\n   * \n   * @param key \n   * @param value \n   * @param namespace \n   */\n  public legacy_set(key: string, value: string, namespace: string) {\n    const dictionary = this.#dictionaries.get(namespace);\n\n    if (!dictionary) {\n      // Create a new dictionary\n      this.createDictionary(namespace);\n\n      // Set value\n      this.legacy_set(key, value, namespace);\n    } else {\n      // Set value\n      dictionary.set(key, value);\n    }\n  }\n\n  /**\n   * Fetches JSON value from local storage with key `key` and namespace\n   * `namespace`.\n   * \n   * @param key \n   * @param namespace \n   */\n  public legacy_get(key: string, namespace: string) {\n    const dictionary = this.#dictionaries.get(namespace);\n\n    if (!dictionary) return;\n\n    return dictionary.get(key);\n  }\n\n  /**\n   * Export dictionars to JSOn.\n   */\n  public legacy_doExport() {\n    const LOCAL_STORAGE_NAMESPACE = this.#localStorageNamespace;\n\n    const lsprefix = `${LOCAL_STORAGE_NAMESPACE}:`;\n\n    const dictionaries: { [key: string]: ExportTerm[] } = {};\n\n    Object.keys(localStorage).filter(lskey => lskey.startsWith(lsprefix)).forEach(lskey => {\n      const namespacedKey = lskey.substr(lsprefix.length);\n\n      const colonIdx = namespacedKey.indexOf(':');\n\n      const namespace = namespacedKey.substring(0, colonIdx);\n      const key = namespacedKey.substring(colonIdx + 1, namespacedKey.length);\n\n      const value = this.legacy_get(key, namespace);\n\n      const term = key;\n      const description = value;\n\n      assert(typeof description !== \"undefined\");\n\n      if (!dictionaries.hasOwnProperty(namespace)) dictionaries[namespace] = [];\n\n      const exportTerm: ExportTerm = { term, description };\n\n      dictionaries[namespace].push(exportTerm);\n    });\n\n    const exportObject: ExportObject = { dictionaries: [] };\n\n    Object.keys(dictionaries).forEach((namespace) => {\n      const terms = dictionaries[namespace];\n      const subdictionary: ExportSubdictionary = { namespace, terms };\n      exportObject.dictionaries.push(subdictionary);\n    });\n\n    return exportObject as ExportObject;\n  }\n\n  /**\n   * Imports dictionaries from JSON.\n   * \n   * @param importObject \n   */\n  public legacy_doImport(importObject: ImportObject) {\n    if (importObject.hasOwnProperty('dictionaries')) {\n      const obj = importObject as ExportObject;\n      const { dictionaries } = obj;\n\n      dictionaries.forEach((dictionary) => {\n        const { namespace, terms } = dictionary;\n\n        terms.forEach((termObject) => {\n          const { term, description } = termObject;\n\n          const key = term;\n          const value = description;\n\n          this.legacy_set(key, value, namespace);\n        });\n      });\n    } else {\n      const obj = importObject as Legacy1ExportObject;\n\n      const { terms } = obj;\n      const namespace = DEFAULT_NAMESPACE;\n\n      terms.forEach((termObject) => {\n        const { term, description } = termObject;\n\n        const key = term;\n        const value = description;\n\n        this.legacy_set(key, value, namespace);\n      });\n    }\n  }\n\n  /**\n   * Returns a set of all the available namespaces.\n   */\n  public legacy_getAllNamespaces() {\n    const namespacesSet = new Set<string>();\n\n    for (const [dictionaryNamespace, _] of this.#dictionaries.entries()) {\n      namespacesSet.add(dictionaryNamespace);\n    }\n\n    return namespacesSet;\n  }\n}\n","import Library from \"./Library\";\n\nconst LOCAL_STORAGE_NAMESPACE = 'tu8rbgh8';\n\nconst library = new Library(LOCAL_STORAGE_NAMESPACE);\n\n\n// Debug stuff\n// @ts-ignore\nwindow.library = library;\n\nexport default {\n  getLibrary: () => {\n    return library;\n  }\n};\n","import React from \"react\";\nimport \"./Button.scss\";\n\ninterface Props {\n  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n}\n \ninterface State {\n  onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  classes: string;\n}\n\nclass Button extends React.Component<Props, State> {\n\n  state: State = {\n    onClick: () => { },\n    classes: ''\n  }\n\n  componentDidMount() {\n    const { onClick = () => { } } = this.props;\n    const { disabled = false, className = '' } = this.props;\n\n    // væri líka hægt að nota `classnames` pakka\n    const classes = [\n      'Button', className ? className : null,\n      disabled ? 'Button--disabled' : null\n    ].filter(Boolean).join(' ');\n\n    this.setState({ onClick, classes });\n  }\n\n  render() {\n\n    const { children, disabled = false, style } = this.props;\n    const { onClick, classes } = this.state;\n\n    return (\n      <button\n        onClick={onClick}\n        disabled={disabled}\n        className={classes}\n        style={style}\n        >\n        {children}\n      </button>\n    );\n  }\n}\n\nexport default Button;\n","import React, { Component } from \"react\";\nimport Button from \"../button/Button\";\n\nimport \"./SearchResult.scss\";\n\ninterface Props {\n  term: string;\n  onSelection: (term: string) => void;\n}\n\nclass SearchResult extends Component<Props> {\n  handleClick = () => {\n    const { term, onSelection } = this.props;\n    onSelection(term);\n  }\n\n  render() {\n    const { term } = this.props;\n\n    return (\n      <li className=\"SearchResult__item\">\n        <Button\n          style={{ width: '100%', borderTop: 'none', borderLeft: 'none', borderRight: 'none' }}\n          onClick={this.handleClick}>\n          {term}\n        </Button>\n      </li>\n    );\n  }\n}\n\nexport default SearchResult;\n","import React, { Component } from \"react\";\nimport SearchResult from \"../search-result/SearchResult\";\n\n\nimport \"./SearchResults.scss\";\n\n\ninterface Props {\n  query?: string;\n  onSelection: (term: string) => void;\n  terms?: string[];\n}\n\ninterface State {}\n\nclass SearchResults extends Component<Props, State> {\n  render() {\n    const { onSelection, terms } = this.props;\n\n    return (\n      <div className=\"SearchResults\">\n        <div className=\"SearchResults__container\">\n          <ul className=\"SearchResults__list\">\n            {terms &&\n              terms.map((term, idx) => (\n                <SearchResult key={idx} term={term} onSelection={onSelection} />\n              ))}\n          </ul>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default SearchResults;\n","import React from \"react\";\nimport Button from '../button/Button';\n\nimport \"./InputSearch.scss\";\n\n\ninterface Props {\n  onChange?: (value: string) => void;\n  value?: string;\n  suggestions?: string[];\n  autocomplete?: (event: React.KeyboardEvent<HTMLInputElement>, value: string, suggestions: string[]) => string;\n}\n\n\nconst defaultAutocomplete = (e: React.KeyboardEvent<HTMLInputElement>, value: string, suggestions: string[]) => {\n  if (e.key === 'Enter' || e.key === 'Tab') {\n\n    if (suggestions) {\n      if (suggestions.length > 0) {\n        const topSuggestion = suggestions[0];\n\n        if (e.key === 'Tab') {\n          if (value) {\n            if (value !== topSuggestion && topSuggestion.startsWith(value)) {\n              e.preventDefault();\n              return topSuggestion;\n            }\n          }\n        } else {\n          if (value !== topSuggestion) {\n            return topSuggestion;\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n}\n\ninterface State {}\n\nclass InputSearch extends React.Component<Props, State> {\n\n  handleOnChangeSearchValue = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { target: { value: searchValue } } = e;\n    this.setSearchValue(searchValue);\n  }\n\n  handleOnClickClear = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n    this.setSearchValue('');\n  }\n\n  handleOnKeyDownSearchValue = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const { autocomplete, value, suggestions } = this.props;\n\n    if (autocomplete) {\n      if (value && suggestions) {\n        const autocompleteValue = autocomplete(e, value, suggestions)\n        this.setSearchValue(autocompleteValue);\n      }\n    } else {\n      if (value && suggestions) {\n        const autocompleteValue = defaultAutocomplete(e, value, suggestions)\n        this.setSearchValue(autocompleteValue);\n      }\n    }\n  }\n\n  setSearchValue = (searchValue: string) => {\n    const { onChange } = this.props;\n    if (onChange) {\n      onChange(searchValue);\n    }\n  }\n\n  render() {\n    const { value } = this.props;\n\n    return (\n      <div className=\"InputSearch\">\n        <label className=\"InputSearch__search\">\n          <span className=\"InputSearch__label\">Search:</span>\n          <input\n            spellCheck={false}\n            className=\"InputSearch__input\"\n            type=\"text\"\n            value={value}\n            onKeyDown={this.handleOnKeyDownSearchValue}\n            onChange={this.handleOnChangeSearchValue}\n          />\n\n        </label>\n        <Button\n          onClick={this.handleOnClickClear}\n          style={{ border: 'none' }}\n        >clear</Button>\n      </div>\n    );\n  }\n}\n\nexport default InputSearch;\n","import React from 'react'\nimport Button from '../button/Button';\n\nimport \"./ImportButton.scss\";\n\ninterface Props {\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n\n  onImport: (text: string) => void;\n}\n\ninterface State {}\n\nclass ImportButton extends React.Component<Props, State> {\n  inputElement: HTMLInputElement | null = null;\n\n  onClick = () => {\n    if (this.inputElement) {\n      this.inputElement.click();\n    }\n  }\n\n  handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { onImport } = this.props;\n\n    const reader = new FileReader();\n    reader.onload = function (e2) {\n\n      if (e2 && e2.target) {\n        const { target } = e2 as any;\n        \n        const text = target.result as string;\n        onImport(text);\n      }\n    };\n\n    if (e && e.target) {\n      const { files } = e.target;\n      if (files) {\n        reader.readAsText(files[0]);\n      }\n    }\n    \n  }\n\n  render() {\n    const { children, style } = this.props;\n\n    return (\n      <React.Fragment>\n        <Button style={style} onClick={this.onClick}>{ children }</Button>\n        <input onChange={this.handleFileChange} ref={input => this.inputElement = input} className=\"ImportButton__input\" type=\"file\" />\n      </React.Fragment>\n    )\n  }\n}\n\nexport default ImportButton;\n","import React from 'react'\nimport Button from '../button/Button';\n\nimport \"./ExportButton.scss\";\n\ninterface Props {\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n  getContent?: () => string; // content (href)\n  filename?: string; // filename (download)\n}\n\ninterface State {}\n\nclass ExportButton extends React.Component<Props, State> {\n  anchor: HTMLAnchorElement | null = null;\n\n  onClick = () => {\n    const { getContent, filename } = this.props;\n\n    if (this.anchor && getContent && filename ) {\n      const content = getContent();\n\n      // Content here should be a JSON data structure.\n      const uriEncodedString = encodeURIComponent(content);\n\n      const data = `text/text;charset=utf-8,${uriEncodedString}`;\n      const href = `data:${data}`;\n      const download = filename;\n\n      this.anchor.href = href;\n      this.anchor.download = download;\n\n      this.anchor.click();\n    }\n  }\n\n  render() {\n    const { children, style } = this.props;\n\n    return (\n      <React.Fragment>\n        <Button style={style} onClick={this.onClick}>{children}</Button>\n        <a ref={anchor => this.anchor = anchor} style={{ display: 'none' }}></a>\n      </React.Fragment>\n    )\n  }\n}\n\nexport default ExportButton;\n","import React from 'react'\nimport Button from '../button/Button';\n\nimport \"./ConfirmationButton.scss\";\n\ninterface Props {\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  confirmationMessage?: string;\n}\n\ninterface State {}\n\n\nclass ConfirmationButton extends React.Component<Props, State> {\n  onClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n    const { onClick: exteriorOnClick } = this.props;\n\n    const { confirmationMessage = 'Are you sure?' } = this.props;\n    const response = window.confirm(confirmationMessage);\n\n    if (response === true) {\n      // Pressed OK\n      if (exteriorOnClick) {\n        exteriorOnClick(e);\n      }\n    } else {\n      // Pressed Cancel\n    }\n  }\n\n  render() {\n    const { children, style } = this.props;\n\n    return (\n      <React.Fragment>\n        <Button style={style} onClick={this.onClick}>{children}</Button>\n      </React.Fragment>\n    )\n  }\n}\n\nexport default ConfirmationButton;\n","import React from \"react\";\n\nimport \"./InputText.scss\";\n\ninterface Props {\n  value?: string;\n  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;\n}\n\ninterface State {}\n\nclass InputText extends React.Component<Props, State> {\n\n  render() {\n    const { value, onChange } = this.props;\n\n    return (\n      <input\n        type=\"text\"\n        className=\"InputText__input\"\n        value={value}\n        placeholder={'namespace'}\n        onChange={onChange}\n      />\n    );\n  }\n}\n\nexport default InputText;\n","import React, { Component } from \"react\";\nimport api from \"../../api\";\nimport SearchResults from \"../../components/search-results/SearchResults\";\nimport InputSearch from \"../../components/input-search/InputSearch\";\nimport ImportButton from \"../../components/import-button/ImportButton\";\nimport ExportButton from \"../../components/export-button/ExportButton\";\nimport ConfirmationButton from \"../../components/confirmation-button/ConfirmationButton\";\nimport InputText from \"../../components/input-text/InputText\";\n\nimport \"./Home.scss\";\n\nfunction leftpad(str: string | number, pad: string) {\n  return String(pad + str).slice(-pad.length);\n}\n\nfunction getDateNowString() {\n  // date\n  const d = new Date();\n\n  let ds = \"\"; // date string\n  ds += leftpad(d.getFullYear(), \"0000\") + \"-\";\n  ds += leftpad(d.getMonth(), \"00\") + \"-\";\n  ds += leftpad(d.getDate(), \"00\") + \"-\";\n  ds += leftpad(d.getHours(), \"00\");\n  ds += leftpad(d.getMinutes(), \"00\");\n  ds += leftpad(d.getSeconds(), \"00\");\n\n  return ds;\n}\n\ninterface Props { }\n\ninterface State {\n  resultText: string;\n  searchValue: string;\n  placeholderText: string;\n  terms: { namespace: string; key: string }[];\n  namespace: string;\n  flattenedTerms: string[];\n  namespaces: string[];\n}\n\nconst DEFAULT_PLACEHOLDER_TEXT = \"\";\nconst DEFAULT_NAMESPACE = \"default\";\n\nclass Home extends Component<Props, State> {\n  state: State = {\n    resultText: \"\",\n    searchValue: \"\",\n    placeholderText: DEFAULT_PLACEHOLDER_TEXT,\n    terms: [],\n    namespace: DEFAULT_NAMESPACE,\n    flattenedTerms: [],\n    namespaces: []\n  };\n\n  updateTerms(\n    searchValue: string = this.state.searchValue,\n    namespace: string = this.state.namespace\n  ) {\n    const library = api.getLibrary();\n\n    const result = library.legacy_searchTermsAndDescriptions(searchValue, namespace);\n\n    const { terms, namespaceExists, namespaces } = result;\n\n    const didNotExistBefore = !namespaces.includes(this.state.namespace);\n\n    if (\n      this.state.namespace !== \"*\" &&\n      didNotExistBefore &&\n      namespaces.includes(namespace)\n    ) {\n      this.setState({ searchValue: \"\" });\n    }\n\n    let flattenedTerms: string[];\n\n    if (namespaceExists) {\n      flattenedTerms = terms.map(term => {\n        return term.key;\n      });\n    } else {\n      flattenedTerms = terms.map(term => {\n        return `${term.namespace}: ${term.key}`;\n      });\n    }\n\n    this.setState({ terms, flattenedTerms, namespaces });\n\n    return {\n      terms,\n      flattenedTerms,\n      namespaces\n    };\n  }\n\n  resolveSearch(namespace: string, searchValue: string) {\n    const { terms } = this.updateTerms(searchValue, namespace);\n\n    const library = api.getLibrary();\n\n    const resultText = library.legacy_get(searchValue, namespace);\n\n    if (typeof resultText === \"string\") {\n      this.setState({ resultText });\n    } else if (this.state.resultText.length > 0) {\n      this.setState({ resultText: \"\" });\n    }\n\n    if (searchValue.trim().length > 0 && terms.length > 0) {\n      const key = terms[0].key;\n      const placeholderText = library.legacy_get(key, namespace);\n\n      if (placeholderText) {\n        this.setState({ placeholderText });\n      }\n    } else {\n      const { placeholderText } = this.state;\n\n      if (placeholderText !== DEFAULT_PLACEHOLDER_TEXT) {\n        this.setState({ placeholderText: DEFAULT_PLACEHOLDER_TEXT });\n      }\n    }\n\n    this.setState({ terms });\n  }\n\n  setSearchValue = (searchValue: string) => {\n    const { namespace, namespaces } = this.state;\n    this.setState({ searchValue });\n\n    if (namespaces.includes(namespace)) {\n      this.resolveSearch(namespace, searchValue);\n    } else if (namespace === \"*\") {\n      const index = searchValue.indexOf(\":\");\n      const originalSearchValue = searchValue;\n\n      if (index >= 0) {\n        // Has split\n\n        const namespace = originalSearchValue.substring(0, index).trim();\n        const searchValue = originalSearchValue\n          .substring(index + 1, originalSearchValue.length)\n          .trim();\n\n        this.resolveSearch(namespace, searchValue);\n      } else {\n        // Search everything\n        this.resolveSearch(\"*\", searchValue);\n      }\n    } else {\n      // use to pick namespace\n      // TODO: this is broken\n      // this.setNamespace(searchValue.trim());\n    }\n  };\n\n  setTermDescription(title: string, description: string) {\n    const { namespace, namespaces } = this.state;\n\n    const library = api.getLibrary();\n\n    if (namespaces.includes(namespace)) {\n      const key = title.trim().toLowerCase();\n      const value = description;\n\n      if (key.length > 0) {\n        if (value.length > 0) {\n          library.legacy_set(key, value, namespace);\n        } else {\n          library.legacy_remove(key, namespace);\n        }\n      }\n      this.updateTerms();\n    } else if (namespace === \"*\") {\n      const index = title.indexOf(\":\");\n\n      const originalTitle = title;\n\n      if (index >= 0) {\n        const namespace = originalTitle.substring(0, index).trim();\n        const title = originalTitle\n          .substring(index + 1, originalTitle.length)\n          .trimLeft();\n\n        const key = title.trim().toLowerCase();\n        const value = description;\n\n        if (key.length > 0) {\n          if (value.length > 0) {\n            library.legacy_set(key, value, namespace);\n          } else {\n            library.legacy_remove(key, namespace);\n          }\n        }\n        this.updateTerms(title, namespace);\n      }\n    } else {\n      const key = title.trim().toLowerCase();\n      const value = description;\n\n      if (key.length > 0) {\n        if (value.length > 0) {\n          library.legacy_set(key, value, namespace);\n        } else {\n          library.legacy_remove(key, namespace);\n        }\n      }\n      this.updateTerms();\n    }\n  }\n\n  setNamespace(namespace: string) {\n    const { searchValue } = this.state;\n\n    this.setState({ placeholderText: \"\" });\n\n    this.updateTerms(searchValue, namespace);\n\n    this.setState({ namespace });\n  }\n\n  forceRerender() {\n    this.setState({});\n  }\n\n  // Lifecycle methods\n\n  componentDidMount() {\n    const { searchValue, namespace } = this.state;\n    this.setSearchValue(searchValue);\n    this.setNamespace(namespace);\n  }\n\n  // Handlers\n\n  handleOnChangeTextArea = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const {\n      target: { value: resultText }\n    } = e;\n    const { searchValue, namespaces } = this.state;\n\n    const namespace = this.state.namespace.trim();\n\n    if (searchValue.trim().length > 0) {\n      if (namespaces.includes(namespace)) {\n        this.setState({\n          resultText\n        });\n\n        this.setTermDescription(searchValue, resultText);\n      } else if (namespace === \"*\") {\n        const index = searchValue.indexOf(\":\");\n\n        if (index >= 0) {\n          const right = searchValue\n            .substring(index + 1, searchValue.length)\n            .trim();\n\n          if (right.length > 0) {\n            this.setState({\n              resultText\n            });\n            this.setTermDescription(searchValue, resultText);\n          }\n        }\n      } else {\n        // CREATE NEW (???)\n        this.setTermDescription(searchValue, resultText);\n      }\n    }\n  };\n\n  handleOnSelection = (searchValue: string) => {\n    const { namespace, namespaces } = this.state;\n\n    if (namespaces.includes(namespace) || namespace.trim() === '*') {\n      this.setSearchValue(searchValue);\n    } else {\n      this.setNamespace(searchValue);\n    }\n  };\n\n  handleOnChangeSearchValue = (searchValue: string) => {\n    this.setSearchValue(searchValue);\n  };\n\n  handleOnImport = (text: string) => {\n    const library = api.getLibrary();\n\n    library.legacy_doImport(JSON.parse(text));\n    this.updateTerms();\n  };\n\n  handleOnClearEverything = () => {\n    const library = api.getLibrary();\n\n    library.removeEverything();\n    this.updateTerms();\n  };\n\n  handleGetContent = () => {\n    const library = api.getLibrary();\n\n    return JSON.stringify(library.legacy_doExport());\n  };\n\n  handleOnChangeNamespace = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const namespace = e.target.value.trim();\n\n    this.setNamespace(namespace);\n\n    if (namespace.length === 0) {\n      this.setSearchValue('');\n      this.setState({ placeholderText: '' })\n    }\n  };\n\n  autocomplete = (\n    e: React.KeyboardEvent<HTMLInputElement>,\n    value: string,\n    suggestions: string[]\n  ) => {\n    const { namespace } = this.state;\n\n    let lookupValue;\n    let derivedNamespace;\n    let derived = false;\n\n    let space1 = '';\n    let space2 = '';\n    let space3 = '';\n    let space4 = '';\n\n    if (namespace === \"*\") {\n      const index = value.indexOf(\":\");\n\n      if (index >= 0) {\n        derived = true;\n\n        const leftPart = value.substring(0, index);\n        const rightPart = value.substring(index + 1, value.length);\n\n        derivedNamespace = leftPart.trim();\n        lookupValue = rightPart.trim();\n\n        const idx1 = leftPart.indexOf(derivedNamespace);\n        const idx2 = derivedNamespace.length + idx1;\n\n        const idx3 = rightPart.indexOf(lookupValue);\n        const idx4 = lookupValue.length + idx3;\n\n\n        space1 = ' '.repeat(idx1);\n        space2 = ' '.repeat(leftPart.length - idx2);\n        space3 = ' '.repeat(idx3);\n        space4 = ' '.repeat(rightPart.length - idx4);\n\n      } else {\n        lookupValue = value;\n      }\n    } else {\n      lookupValue = value;\n    }\n\n    if (e.key === \"Enter\" || e.key === \"Tab\") {\n      if (suggestions.length > 0) {\n        const topSuggestion = suggestions[0];\n\n        if (derived) {\n          if (\n            lookupValue !== topSuggestion &&\n            topSuggestion.startsWith(lookupValue)\n          ) {\n\n            e.preventDefault();\n            return `${space1}${derivedNamespace}${space2}:${space3}${topSuggestion}${space4}`;\n          }\n        } else if (namespace === \"*\") {\n          // Degenerate case\n          e.preventDefault();\n\n          return topSuggestion;\n        } else {\n          if (\n            lookupValue !== topSuggestion &&\n            topSuggestion.startsWith(lookupValue)\n          ) {\n            e.preventDefault();\n            return topSuggestion;\n          }\n        }\n\n        if (\n          lookupValue !== topSuggestion &&\n          topSuggestion.startsWith(lookupValue)\n        ) {\n          e.preventDefault();\n\n          if (derived) {\n            return `${space1}${derivedNamespace}${space2}:${space3}${topSuggestion}${space4}`;\n          } else {\n            return topSuggestion;\n          }\n        }\n\n\n      }\n    }\n\n    return value;\n  };\n\n  render() {\n    const {\n      searchValue,\n      resultText,\n      placeholderText,\n      flattenedTerms,\n      namespace,\n      namespaces\n    } = this.state;\n\n    const ds = getDateNowString();\n    const filename = `dictionary-${ds}.json`;\n\n    let listedTerms;\n\n    if (namespaces.includes(namespace)) {\n      listedTerms = flattenedTerms;\n    } else {\n      if (namespace === \"*\") {\n        listedTerms = flattenedTerms;\n      } else {\n        listedTerms = namespaces.filter(ns =>\n          ns.startsWith(namespace)\n        );\n      }\n    }\n\n    return (\n      <div className=\"Home\">\n        <div className=\"Home__content\">\n          <div className=\"Home__top\">\n            <div className=\"Home__topLeft\">\n              <ImportButton\n                onImport={this.handleOnImport}\n                style={{ border: \"none\" }}\n              >\n                Import\n              </ImportButton>\n              <ExportButton\n                getContent={this.handleGetContent}\n                filename={filename}\n                style={{ borderTop: \"none\", borderBottom: \"none\" }}\n              >\n                Export\n              </ExportButton>\n            </div>\n            <div className=\"Home__topRight\">\n              <InputText\n                value={namespace}\n                onChange={this.handleOnChangeNamespace}\n              />\n            </div>\n          </div>\n          <div className=\"Home__center\">\n            <SearchResults\n              terms={listedTerms}\n              query={searchValue}\n              onSelection={this.handleOnSelection}\n            />\n            <div className=\"Home__main\" style={{ borderLeft: \"none\" }}>\n              <InputSearch\n                value={searchValue}\n                suggestions={listedTerms}\n                autocomplete={this.autocomplete}\n                onChange={this.handleOnChangeSearchValue}\n              />\n              <textarea\n                className=\"Home__result\"\n                onChange={this.handleOnChangeTextArea}\n                rows={20}\n                cols={50}\n                value={resultText}\n                placeholder={placeholderText}\n                spellCheck={false}\n              />\n            </div>\n          </div>\n          <div className=\"Home__bottom\">\n            <ConfirmationButton\n              onClick={this.handleOnClearEverything}\n              confirmationMessage={\n                \"Are you sure you want to delete all the terms?\"\n              }\n              style={{\n                backgroundColor: \"rgb(255, 180, 180)\",\n                color: \"rgb(180, 0, 0)\",\n                borderColor: \"rgb(255, 140, 140)\"\n              }}\n            >\n              DELETE EVERYTHING\n            </ConfirmationButton>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Home;\n","import React from 'react';\n\nimport './SystemPages.scss';\n\nexport default function NotFound() {\n  return (\n    <div className=\"system-page\">\n      NotFound\n    </div>\n  )\n};\n","import React from 'react';\nimport Helmet from 'react-helmet';\nimport { Route, Switch, withRouter } from 'react-router-dom';\n\nimport Home from './routes/home/Home';\nimport NotFound from './routes/system-pages/NotFound';\n\nimport './App.scss';\n\ntype Props = {\n  location: Location;\n};\n\nfunction App(props: Props) {\n  return (\n    <React.Fragment>\n      <Helmet defaultTitle=\"Dictionary\" />\n      <div className=\"App\">\n        <main className=\"App__main\">\n          <Switch location={props.location}>\n            <Route path=\"/\" exact component={Home} />\n            <Route component={NotFound} />\n          </Switch>\n        </main>\n      </div>\n    </React.Fragment>\n  );\n}\n\nexport default withRouter(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter, HashRouter } from 'react-router-dom';\n\nimport './index.scss';\nimport App from './App';\n\nReactDOM.render(\n  (\n    <HashRouter>\n      <App />\n    </HashRouter>\n  ),\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}