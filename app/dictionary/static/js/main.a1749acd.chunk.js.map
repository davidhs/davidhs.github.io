{"version":3,"sources":["api/Dictionary.ts","api/lib.ts","api/vaults/StorageVault.ts","api/vaults/CachedVault.ts","api/Library.ts","api/index.ts","components/button/Button.tsx","components/search-result/SearchResult.tsx","components/search-results/SearchResults.tsx","components/input-search/InputSearch.tsx","components/import-button/ImportButton.tsx","components/export-button/ExportButton.tsx","components/confirmation-button/ConfirmationButton.tsx","components/input-text/InputText.tsx","routes/home/Home.tsx","routes/system-pages/NotFound.tsx","App.tsx","index.tsx"],"names":["Dictionary","vault","this","term","get","description","set","remove","clear","assert","condition","message","Error","StorageVault","storage","localStorage","key","item","getItem","undefined","Object","keys","length","value","has","setItem","removeItem","size","CachedVault","keyPrefix","Map","filter","startsWith","map","substring","forEach","lskey","rawItem","JSON","parse","push","prefixedKey","stringify","delete","x","Library","localStorageNamespace","lsprefix","namespacesSet","Set","namespacedKey","substr","colonIdx","indexOf","namespace","add","dictionary","hasDictionary","dictionaryNamespace","removeDictionary","paramQuery","paramNamespace","trim","toLowerCase","isFullsearch","query","namespaceExists","allTerms","lspnamespace","lspkey","namespaceList","Array","from","sort","escapedQuery","replace","a","b","localeCompare","terms","namespaces","startsWithRegex","RegExp","notStartsHasRegex","hasRegex","markedTerms","termsStartingWithQuery","fullkey","match","termsWithMatchingTerms","termsWithMatchingDescription","v","legacy_get","termsAdditionalInFullsearch","createDictionary","legacy_set","LOCAL_STORAGE_NAMESPACE","dictionaries","hasOwnProperty","exportTerm","exportObject","subdictionary","importObject","termObject","entries","library","window","Button","state","onClick","classes","props","disabled","className","Boolean","join","setState","children","style","React","Component","SearchResult","handleClick","onSelection","width","borderTop","borderLeft","borderRight","SearchResults","idx","defaultAutocomplete","e","suggestions","topSuggestion","preventDefault","InputSearch","handleOnChangeSearchValue","searchValue","target","setSearchValue","handleOnClickClear","handleOnKeyDownSearchValue","autocomplete","autocompleteValue","onChange","spellCheck","type","onKeyDown","border","ImportButton","inputElement","click","handleFileChange","onImport","reader","FileReader","onload","e2","text","result","files","readAsText","Fragment","ref","input","ExportButton","anchor","getContent","filename","content","uriEncodedString","encodeURIComponent","data","href","download","display","ConfirmationButton","exteriorOnClick","confirmationMessage","confirm","InputText","placeholder","leftpad","str","pad","String","slice","Home","resultText","placeholderText","flattenedTerms","includes","resolveSearch","index","originalSearchValue","handleOnChangeTextArea","setTermDescription","handleOnSelection","setNamespace","handleOnImport","api","legacy_doImport","updateTerms","handleOnClearEverything","removeEverything","handleGetContent","legacy_doExport","handleOnChangeNamespace","lookupValue","derivedNamespace","derived","space1","space2","space3","space4","leftPart","rightPart","idx1","idx2","idx3","idx4","repeat","legacy_searchTermsAndDescriptions","didNotExistBefore","title","legacy_remove","originalTitle","trimLeft","listedTerms","ds","d","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getDateNowString","ns","borderBottom","rows","cols","backgroundColor","color","borderColor","NotFound","withRouter","defaultTitle","location","path","exact","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a1749acd.chunk.js","sourcesContent":["import { Vault } from \"./types\";\n\n/**\n * TODO: a dictionary should not concern itself with local storage or name-\n * spaces (ideally).\n */\nexport default class Dictionary {\n  #vault: Vault<string>;\n  \n  /**\n   * The vault **must** be ready before constructing a dictionary.\n   * \n   * @param vault\n   */\n  constructor(vault: Vault<string>) {\n    this.#vault = vault;\n  }\n\n  /**\n   * Retrieves the description for the term, or `undefined` if the term is not\n   * defined.\n   * \n   * @param term \n   */\n  public get(term: string): string | undefined {\n    return this.#vault.get(term);\n  }\n\n  /**\n   * Sets the term with the description.\n   * \n   * @param term \n   * @param description \n   */\n  public set(term: string, description: string): void {\n    this.#vault.set(term, description);\n  }\n\n  /**\n   * Removes the term if exists.  If it doesn't exist then nothing happens.\n   * \n   * @param term \n   */\n  public remove(term: string): void {\n    this.#vault.remove(term);\n  }\n\n  /**\n   * Removes all terms and descriptions from this dictionary.\n   */\n  public clear(): void {\n    this.#vault.clear();\n  }\n}\n","/**\n * Asserts condition `condition`.\n * \n * @param condition \n * @param message \n */\nexport function assert(condition: boolean, message = \"Assertion failed\"): asserts condition {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\n/**\n * A function to escape characters in a string so they won't be treated as\n * meta-characters in the construction of a regular expresion.\n * \n * @param str\n */\nexport function escapeRegExp(str: string) {\n  // $& means the whole matched string\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import { Vault } from \"../types\";\n\n/**\n * Concrete implementation of a vault using Local Storage as its backend.\n */\nexport default class StorageVault implements Vault<string> {\n  #backend: Storage;\n  #needsToUpdateCachedKeys: boolean;\n  #cachedKeys: string[];\n\n  /**\n   * Defaults to using local storage.\n   * \n   * @param storage \n   */\n  constructor(storage: Storage = localStorage) {\n    this.#backend = storage;\n    this.#needsToUpdateCachedKeys = true;\n    this.#cachedKeys = [];\n  }\n\n  public get(key: string) {\n    const item = this.#backend.getItem(key);\n\n    return item !== null ? item : undefined;\n  }\n\n  /**\n   * DO NOT MODIFY THE KEYS!\n   */\n  keys() {\n    if (this.#needsToUpdateCachedKeys) {\n      this.#cachedKeys = Object.keys(this.#backend);\n      this.#needsToUpdateCachedKeys = false;\n    }\n\n    return this.#cachedKeys;\n  }\n\n  size() {\n    return this.#backend.length;\n  }\n\n  has(key: string) {\n    return this.#backend.getItem(key) !== null;\n  }\n\n  set(key: string, value: string) {\n    if (!this.has(key)) {\n      this.#needsToUpdateCachedKeys = true;\n    }\n\n    this.#backend.setItem(key, value);\n  }\n\n  remove(key: string) {\n    if (this.has(key)) {\n      this.#needsToUpdateCachedKeys = true;\n    }\n\n    this.#backend.removeItem(key);\n  }\n\n  clear() {\n    if (this.size() > 0) {\n      this.#needsToUpdateCachedKeys = true;\n    }\n    \n    this.#backend.clear();\n  }\n}\n\n\n","import { Vault } from \"../types\";\nimport StorageVault from \"./StorageVault\";\n\n/**\n * Vault which caches has a \"front\" cache.\n */\nexport default class CachedVault<T> implements Vault<T> {\n  #backendVault: StorageVault;\n  #keyPrefix: string;\n  #cache: Map<string, T>;\n\n  /**\n   * @param keyPrefix \n   */\n  constructor(keyPrefix: string) {\n    // TODO: be able to choose another backend?\n    this.#keyPrefix = keyPrefix;\n\n    this.#backendVault = new StorageVault();\n\n    // A mapping from terms to descriptions (or anything really)\n    this.#cache = new Map();\n\n    ////////////////////////////////\n    // Read everything into cache //\n    ////////////////////////////////\n\n    // NOTE: we want to store keys unprefixed in the cache and prefixed in the\n    // backend vault.\n\n    // Here we unprefix the string.\n    Object.keys(this.#backendVault)\n      .filter(key => key.startsWith(this.#keyPrefix))\n      .map(key => key.substring(this.#keyPrefix.length))\n      .forEach((key) => {\n        const lskey = `${this.#keyPrefix}${key}`;\n        const rawItem = this.#backendVault.get(lskey);\n\n        if (typeof rawItem !== \"undefined\") {\n          this.#cache.set(key, JSON.parse(rawItem));\n        }\n      });\n  }\n\n  /**\n   * WARNING: BE VERY CAREFUL!\n   */\n  public getCache() {\n    return this.#cache;\n  }\n\n  public keys() {\n    const keys: string[] = [];\n\n    for (const key of this.#cache.keys()) {\n      keys.push(`${this.#keyPrefix}${key}`);\n    }\n\n    return keys;\n  }\n\n  has(key: string) {\n    return this.#cache.has(key);\n  }\n\n  size() {\n    return this.#cache.size;\n  }\n\n\n  /**\n   * Retrieves the value for key `key`.\n   * \n   * @param key \n   */\n  public get(key: string): T | undefined {\n    return this.#cache.get(key);\n  }\n\n  /**\n   * Set key-value\n   * \n   * @param key \n   * @param value \n   */\n  public set(key: string, value: T): void {\n    ///////////////\n    // Set cache //\n    ///////////////\n\n    this.#cache.set(key, value);\n\n    ///////////////////////\n    // Set local storage //\n    ///////////////////////\n\n    const prefixedKey = `${this.#keyPrefix}${key}`;\n    this.#backendVault.set(prefixedKey, JSON.stringify(value));\n  }\n\n  /**\n   * Remove key\n   * \n   * @param key \n   */\n  public remove(key: string): void {\n    this.#cache.delete(key);\n\n    const prefixedKey = `${this.#keyPrefix}${key}`;\n    this.#backendVault.remove(prefixedKey);\n  }\n\n  /**\n   * Removes all entries.\n   */\n  public clear(): void {\n    this.#cache.clear();\n\n    this.#backendVault.keys()\n      .filter(x => x.startsWith(this.#keyPrefix))\n      .forEach(key => this.#backendVault.remove(key));\n  }\n}","import Dictionary from \"./Dictionary\";\nimport { ExportTerm, ExportObject, ExportSubdictionary, Legacy1ExportObject, ImportObject } from \"./types\";\nimport { escapeRegExp, assert } from \"./lib\";\nimport CachedVault from \"./vaults/CachedVault\";\n\n// TODO: need a much more robust name to define dictionary names.\n\n// TODO: maybe I don't want to put terms in lowercase anymore, just have a simple\n// key-value database (string)\n\nconst DEFAULT_NAMESPACE = 'default';\n\n/**\n * The purpose of this class is to be able to probe multiple dictionaries, and\n * keep track of which dictionary is in use, etc.\n * \n * \n */\nexport default class Library {\n  #dictionaries: Map<string, Dictionary>\n  #localStorageNamespace: string;\n\n  /**\n   * TODO: `Library` should NOT concern itself with that it might be using\n   * local storage as its backend, or IndexedDB, or maybe even a remote\n   * storage (SQLite, PostgreSQL).\n   * \n   * TODO: should be able to use whatever backend storage it sees fit as long \n   * as the interface for `get`, `set`, and `remove` is synchronous.\n   * \n   * TODO: supply this with storage method.\n   * \n   * @param localStorageNamespace \n   */\n  constructor(localStorageNamespace: string) {\n    this.#dictionaries = new Map();\n    this.#localStorageNamespace = localStorageNamespace;\n\n    //////////////////////////////\n    // Load in all dictionaries //\n    //////////////////////////////\n\n    {\n      const lsprefix = `${localStorageNamespace}:`;\n\n      const namespacesSet = new Set<string>();\n\n      Object.keys(localStorage)\n        .filter(lskey => lskey.startsWith(lsprefix))\n        .forEach(lskey => {\n          const namespacedKey = lskey.substr(lsprefix.length);\n          const colonIdx = namespacedKey.indexOf(':');\n          const namespace = namespacedKey.substring(0, colonIdx);\n          namespacesSet.add(namespace);\n        });\n\n      namespacesSet.forEach((namespace) => {\n        const keyPrefix = `${localStorageNamespace}:${namespace}:`;\n        const vault = new CachedVault<string>(keyPrefix);\n\n        const dictionary = new Dictionary(vault);\n        this.#dictionaries.set(namespace, dictionary);\n      });\n    }\n  }\n\n  /**\n   * \n   * @param namespace \n   */\n  public hasDictionary(namespace: string): boolean {\n    return this.#dictionaries.has(namespace);\n  }\n\n  /**\n   * Creates a dictionary with the name `namespace`.  If a dictionary with the\n   * same name exists then it throws an error.\n   * \n   * @param namespace \n   * \n   * @throws\n   */\n  public createDictionary(namespace: string): void {\n    assert(!this.hasDictionary(namespace));\n\n    const keyPrefix = `${this.#localStorageNamespace}:${namespace}:`;\n    const vault = new CachedVault<string>(keyPrefix);\n\n    const dictionary = new Dictionary(vault);\n\n    this.#dictionaries.set(namespace, dictionary);\n  }\n\n  /**\n   * Removes as dictionary.  Nothing happens if the dictionary doesn't exist.\n   * \n   * @param namespace \n   */\n  public removeDictionary(namespace: string) {\n    const dictionary = this.#dictionaries.get(namespace);\n\n    if (!dictionary) return;\n\n    dictionary.clear();\n\n    this.#dictionaries.delete(namespace);\n  }\n\n  /**\n   * Removes every single dictionary.\n   */\n  public removeEverything() {\n    for (const dictionaryNamespace of this.#dictionaries.keys()) {\n      this.removeDictionary(dictionaryNamespace);\n    }\n  }\n\n  /**\n   * Search termsn and descriptions\n   * \n   * @param paramQuery \n   * @param paramNamespace \n   */\n  public legacy_searchTermsAndDescriptions(paramQuery: string, paramNamespace: string) {\n    // TODO: this function needs to be completely reworked!\n\n    const namespace = paramNamespace.trim().toLowerCase();\n    const isFullsearch = namespace === '*';\n    const query = paramQuery.trim().toLowerCase();\n    const lsprefix = `${this.#localStorageNamespace}:`;\n    let namespaceExists = false;\n    const namespacesSet = new Set<string>();\n\n    ///////////////////////\n    // Pick up all terms //\n    ///////////////////////\n\n    const allTerms = Object.keys(localStorage)\n      .filter(lskey => lskey.startsWith(lsprefix))\n      .map(lskey => {\n        const namespacedKey = lskey.substr(lsprefix.length);\n\n        const colonIdx = namespacedKey.indexOf(':');\n\n        const lspnamespace = namespacedKey.substring(0, colonIdx);\n        const lspkey = namespacedKey.substring(colonIdx + 1, namespacedKey.length);\n\n        if (namespace === lspnamespace) namespaceExists = true;\n\n        namespacesSet.add(lspnamespace);\n\n        return {\n          namespace: lspnamespace,\n          key: lspkey\n        }\n      }).filter(namespacedKey => {\n        if (namespaceExists) {\n          return namespacedKey.namespace === namespace;\n        } else {\n          // Let everything through\n          return true;\n        }\n      });\n\n    ////////////////////\n    // Filter terms ? //\n    ////////////////////\n\n    const namespaceList = Array.from(namespacesSet).sort();\n\n    // If the query starts with `s` and we have multiple terms that start\n    // with `s` then those terms should be on the top.\n\n    const escapedQuery = escapeRegExp(query);\n\n    allTerms.sort((a, b) => a.key.localeCompare(b.key));\n\n    if (escapedQuery.length === 0) {\n      const returnObject = {\n        terms: allTerms,\n        namespaceExists,\n        namespaces: namespaceList,\n      };\n\n      return returnObject;\n    }\n\n    const startsWithRegex = new RegExp(`^${escapedQuery}.*`);\n    const notStartsHasRegex = new RegExp(`.+${escapedQuery}.*`);\n    const hasRegex = new RegExp(`.*${escapedQuery}.*`);\n\n    // Terms that we encounter we \"mark\" them so that if they're encounted again\n    // they are ignored.\n    const markedTerms = new Set<string>();\n\n    // TODO: does this result in duplicate results?\n\n    // Terms which start with the query string\n    const termsStartingWithQuery = allTerms.filter(namespacedKey => {\n      const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n      if (markedTerms.has(fullkey)) return false;\n\n      if (namespacedKey.key.match(startsWithRegex) !== null) {\n        markedTerms.add(fullkey);\n        return true;\n      }\n\n      return false;\n    }).sort((a, b) => a.key.length - b.key.length);\n\n    // Later, we want to sort terms by similarity.\n\n    const termsWithMatchingTerms = allTerms.filter(namespacedKey => {\n      const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n      if (markedTerms.has(fullkey)) return false;\n\n      if (namespacedKey.key.match(notStartsHasRegex) !== null) {\n        markedTerms.add(fullkey);\n        return true;\n      }\n\n      return false;\n    }).sort((a, b) => a.key.length - b.key.length);\n\n    const termsWithMatchingDescription = allTerms.filter(namespacedKey => {\n      const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n      if (markedTerms.has(fullkey)) return false;\n\n      const { key, namespace } = namespacedKey;\n      const v = this.legacy_get(key, namespace);\n\n      if (typeof v !== 'undefined' && v.match(hasRegex) !== null) {\n        markedTerms.add(fullkey);\n        return true;\n      }\n\n      return false;\n    })\n\n    let termsAdditionalInFullsearch: { namespace: string, key: string }[] = [];\n\n    if (isFullsearch) {\n      termsAdditionalInFullsearch = allTerms.filter(namespacedKey => {\n\n        const fullkey = `${namespacedKey.namespace}:${namespacedKey.key}`\n\n        if (markedTerms.has(fullkey)) return false;\n\n        if (namespacedKey.namespace.startsWith(query)) {\n          markedTerms.add(fullkey);\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    // TODO: this is probably slow...\n\n    // TODO: am I duplicating terms here?\n\n    const returnObject = {\n      terms: [\n        ...termsStartingWithQuery,\n        ...termsWithMatchingTerms,\n        ...termsWithMatchingDescription,\n        ...termsAdditionalInFullsearch,\n      ],\n      namespaceExists,\n      namespaces: namespaceList,\n    };\n\n    return returnObject;\n  }\n\n  /**\n   * Removes JSON value from local storage with key `key` and namespace\n   * `namespace`.\n   * \n   * @param key \n   * @param namespace \n   */\n  public legacy_remove(term: string, namespace: string) {\n    if (!this.hasDictionary(namespace)) return;\n    \n    // TODO: this is inconvenient.\n    const dictionary = this.#dictionaries.get(namespace);\n    \n    assert(typeof dictionary !== \"undefined\");\n\n    dictionary.remove(term);\n  }\n\n  /**\n   * Sets JSON value in local storage with key `key` and namespace `namespace`.\n   * \n   * @param key \n   * @param value \n   * @param namespace \n   */\n  public legacy_set(key: string, value: string, namespace: string) {\n    const dictionary = this.#dictionaries.get(namespace);\n\n    if (!dictionary) {\n      // Create a new dictionary\n      this.createDictionary(namespace);\n\n      // Set value\n      this.legacy_set(key, value, namespace);\n    } else {\n      // Set value\n      dictionary.set(key, value);\n    }\n  }\n\n  /**\n   * Fetches JSON value from local storage with key `key` and namespace\n   * `namespace`.\n   * \n   * @param key \n   * @param namespace \n   */\n  public legacy_get(key: string, namespace: string) {\n    const dictionary = this.#dictionaries.get(namespace);\n\n    if (!dictionary) return;\n\n    return dictionary.get(key);\n  }\n\n  /**\n   * Export dictionars to JSOn.\n   */\n  public legacy_doExport() {\n    const LOCAL_STORAGE_NAMESPACE = this.#localStorageNamespace;\n\n    const lsprefix = `${LOCAL_STORAGE_NAMESPACE}:`;\n\n    const dictionaries: { [key: string]: ExportTerm[] } = {};\n\n    Object.keys(localStorage).filter(lskey => lskey.startsWith(lsprefix)).forEach(lskey => {\n      const namespacedKey = lskey.substr(lsprefix.length);\n\n      const colonIdx = namespacedKey.indexOf(':');\n\n      const namespace = namespacedKey.substring(0, colonIdx);\n      const key = namespacedKey.substring(colonIdx + 1, namespacedKey.length);\n\n      const value = this.legacy_get(key, namespace);\n\n      const term = key;\n      const description = value;\n\n      assert(typeof description !== \"undefined\");\n\n      if (!dictionaries.hasOwnProperty(namespace)) dictionaries[namespace] = [];\n\n      const exportTerm: ExportTerm = { term, description };\n\n      dictionaries[namespace].push(exportTerm);\n    });\n\n    const exportObject: ExportObject = { dictionaries: [] };\n\n    Object.keys(dictionaries).forEach((namespace) => {\n      const terms = dictionaries[namespace];\n      const subdictionary: ExportSubdictionary = { namespace, terms };\n      exportObject.dictionaries.push(subdictionary);\n    });\n\n    return exportObject as ExportObject;\n  }\n\n  /**\n   * Imports dictionaries from JSON.\n   * \n   * @param importObject \n   */\n  public legacy_doImport(importObject: ImportObject) {\n    if (importObject.hasOwnProperty('dictionaries')) {\n      const obj = importObject as ExportObject;\n      const { dictionaries } = obj;\n\n      dictionaries.forEach((dictionary) => {\n        const { namespace, terms } = dictionary;\n\n        terms.forEach((termObject) => {\n          const { term, description } = termObject;\n\n          const key = term;\n          const value = description;\n\n          // WHY IS THIS UNDEFINED?\n          this.legacy_set(key, value, namespace);\n        });\n      });\n    } else {\n      const obj = importObject as Legacy1ExportObject;\n\n      const { terms } = obj;\n      const namespace = DEFAULT_NAMESPACE;\n\n      terms.forEach((termObject) => {\n        const { term, description } = termObject;\n\n        const key = term;\n        const value = description;\n\n        this.legacy_set(key, value, namespace);\n      });\n    }\n  }\n\n  /**\n   * Returns a set of all the available namespaces.\n   */\n  public legacy_getAllNamespaces() {\n    const namespacesSet = new Set<string>();\n\n    for (const [dictionaryNamespace, _] of this.#dictionaries.entries()) {\n      namespacesSet.add(dictionaryNamespace);\n    }\n\n    return namespacesSet;\n  }\n}\n","import Library from \"./Library\";\n\nconst LOCAL_STORAGE_NAMESPACE = 'tu8rbgh8';\n\nconst library = new Library(LOCAL_STORAGE_NAMESPACE);\n\n\n// Debug stuff\n// @ts-ignore\nwindow.library = library;\n\nexport default {\n  getLibrary: () => {\n    return library;\n  }\n};\n","import React from \"react\";\nimport \"./Button.scss\";\n\ninterface Props {\n  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n}\n \ninterface State {\n  onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  classes: string;\n}\n\nclass Button extends React.Component<Props, State> {\n\n  state: State = {\n    onClick: () => { },\n    classes: ''\n  }\n\n  componentDidMount() {\n    const { onClick = () => { } } = this.props;\n    const { disabled = false, className = '' } = this.props;\n\n    // væri líka hægt að nota `classnames` pakka\n    const classes = [\n      'Button', className ? className : null,\n      disabled ? 'Button--disabled' : null\n    ].filter(Boolean).join(' ');\n\n    this.setState({ onClick, classes });\n  }\n\n  render() {\n\n    const { children, disabled = false, style } = this.props;\n    const { onClick, classes } = this.state;\n\n    return (\n      <button\n        onClick={onClick}\n        disabled={disabled}\n        className={classes}\n        style={style}\n        >\n        {children}\n      </button>\n    );\n  }\n}\n\nexport default Button;\n","import React, { Component } from \"react\";\nimport Button from \"../button/Button\";\n\nimport \"./SearchResult.scss\";\n\ninterface Props {\n  term: string;\n  onSelection: (term: string) => void;\n}\n\nclass SearchResult extends Component<Props> {\n  handleClick = () => {\n    const { term, onSelection } = this.props;\n    onSelection(term);\n  }\n\n  render() {\n    const { term } = this.props;\n\n    return (\n      <li className=\"SearchResult__item\">\n        <Button\n          style={{ width: '100%', borderTop: 'none', borderLeft: 'none', borderRight: 'none' }}\n          onClick={this.handleClick}>\n          {term}\n        </Button>\n      </li>\n    );\n  }\n}\n\nexport default SearchResult;\n","import React, { Component } from \"react\";\nimport SearchResult from \"../search-result/SearchResult\";\n\n\nimport \"./SearchResults.scss\";\n\n\ninterface Props {\n  query?: string;\n  onSelection: (term: string) => void;\n  terms?: string[];\n}\n\ninterface State {}\n\nclass SearchResults extends Component<Props, State> {\n  render() {\n    const { onSelection, terms } = this.props;\n\n    return (\n      <div className=\"SearchResults\">\n        <div className=\"SearchResults__container\">\n          <ul className=\"SearchResults__list\">\n            {terms &&\n              terms.map((term, idx) => (\n                <SearchResult key={idx} term={term} onSelection={onSelection} />\n              ))}\n          </ul>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default SearchResults;\n","import React from \"react\";\nimport Button from '../button/Button';\n\nimport \"./InputSearch.scss\";\n\n\ninterface Props {\n  onChange?: (value: string) => void;\n  value?: string;\n  suggestions?: string[];\n  autocomplete?: (event: React.KeyboardEvent<HTMLInputElement>, value: string, suggestions: string[]) => string;\n}\n\n\nconst defaultAutocomplete = (e: React.KeyboardEvent<HTMLInputElement>, value: string, suggestions: string[]) => {\n  if (e.key === 'Enter' || e.key === 'Tab') {\n\n    if (suggestions) {\n      if (suggestions.length > 0) {\n        const topSuggestion = suggestions[0];\n\n        if (e.key === 'Tab') {\n          if (value) {\n            if (value !== topSuggestion && topSuggestion.startsWith(value)) {\n              e.preventDefault();\n              return topSuggestion;\n            }\n          }\n        } else {\n          if (value !== topSuggestion) {\n            return topSuggestion;\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n}\n\ninterface State {}\n\nclass InputSearch extends React.Component<Props, State> {\n\n  handleOnChangeSearchValue = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { target: { value: searchValue } } = e;\n    this.setSearchValue(searchValue);\n  }\n\n  handleOnClickClear = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n    this.setSearchValue('');\n  }\n\n  handleOnKeyDownSearchValue = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    const { autocomplete, value, suggestions } = this.props;\n\n    if (autocomplete) {\n      if (value && suggestions) {\n        const autocompleteValue = autocomplete(e, value, suggestions)\n        this.setSearchValue(autocompleteValue);\n      }\n    } else {\n      if (value && suggestions) {\n        const autocompleteValue = defaultAutocomplete(e, value, suggestions)\n        this.setSearchValue(autocompleteValue);\n      }\n    }\n  }\n\n  setSearchValue = (searchValue: string) => {\n    const { onChange } = this.props;\n    if (onChange) {\n      onChange(searchValue);\n    }\n  }\n\n  render() {\n    const { value } = this.props;\n\n    return (\n      <div className=\"InputSearch\">\n        <label className=\"InputSearch__search\">\n          <span className=\"InputSearch__label\">Search:</span>\n          <input\n            spellCheck={false}\n            className=\"InputSearch__input\"\n            type=\"text\"\n            value={value}\n            onKeyDown={this.handleOnKeyDownSearchValue}\n            onChange={this.handleOnChangeSearchValue}\n          />\n\n        </label>\n        <Button\n          onClick={this.handleOnClickClear}\n          style={{ border: 'none' }}\n        >clear</Button>\n      </div>\n    );\n  }\n}\n\nexport default InputSearch;\n","import React from 'react'\nimport Button from '../button/Button';\n\nimport \"./ImportButton.scss\";\n\ninterface Props {\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n\n  onImport: (text: string) => void;\n}\n\ninterface State {}\n\nclass ImportButton extends React.Component<Props, State> {\n  inputElement: HTMLInputElement | null = null;\n\n  onClick = () => {\n    if (this.inputElement) {\n      this.inputElement.click();\n    }\n  }\n\n  handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const { onImport } = this.props;\n\n    const reader = new FileReader();\n    reader.onload = function (e2) {\n\n      if (e2 && e2.target) {\n        const { target } = e2 as any;\n        \n        const text = target.result as string;\n        onImport(text);\n      }\n    };\n\n    if (e && e.target) {\n      const { files } = e.target;\n      if (files) {\n        reader.readAsText(files[0]);\n      }\n    }\n    \n  }\n\n  render() {\n    const { children, style } = this.props;\n\n    return (\n      <React.Fragment>\n        <Button style={style} onClick={this.onClick}>{ children }</Button>\n        <input onChange={this.handleFileChange} ref={input => this.inputElement = input} className=\"ImportButton__input\" type=\"file\" />\n      </React.Fragment>\n    )\n  }\n}\n\nexport default ImportButton;\n","import React from 'react'\nimport Button from '../button/Button';\n\nimport \"./ExportButton.scss\";\n\ninterface Props {\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n  getContent?: () => string; // content (href)\n  filename?: string; // filename (download)\n}\n\ninterface State {}\n\nclass ExportButton extends React.Component<Props, State> {\n  anchor: HTMLAnchorElement | null = null;\n\n  onClick = () => {\n    const { getContent, filename } = this.props;\n\n    if (this.anchor && getContent && filename ) {\n      const content = getContent();\n\n      // Content here should be a JSON data structure.\n      const uriEncodedString = encodeURIComponent(content);\n\n      const data = `text/text;charset=utf-8,${uriEncodedString}`;\n      const href = `data:${data}`;\n      const download = filename;\n\n      this.anchor.href = href;\n      this.anchor.download = download;\n\n      this.anchor.click();\n    }\n  }\n\n  render() {\n    const { children, style } = this.props;\n\n    return (\n      <React.Fragment>\n        <Button style={style} onClick={this.onClick}>{children}</Button>\n        <a ref={anchor => this.anchor = anchor} style={{ display: 'none' }}></a>\n      </React.Fragment>\n    )\n  }\n}\n\nexport default ExportButton;\n","import React from 'react'\nimport Button from '../button/Button';\n\nimport \"./ConfirmationButton.scss\";\n\ninterface Props {\n  children: any;\n  disabled?: boolean;\n  className?: string;\n  style?: React.CSSProperties;\n  onClick?: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;\n  confirmationMessage?: string;\n}\n\ninterface State {}\n\n\nclass ConfirmationButton extends React.Component<Props, State> {\n  onClick = (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n    const { onClick: exteriorOnClick } = this.props;\n\n    const { confirmationMessage = 'Are you sure?' } = this.props;\n    const response = window.confirm(confirmationMessage);\n\n    if (response === true) {\n      // Pressed OK\n      if (exteriorOnClick) {\n        exteriorOnClick(e);\n      }\n    } else {\n      // Pressed Cancel\n    }\n  }\n\n  render() {\n    const { children, style } = this.props;\n\n    return (\n      <React.Fragment>\n        <Button style={style} onClick={this.onClick}>{children}</Button>\n      </React.Fragment>\n    )\n  }\n}\n\nexport default ConfirmationButton;\n","import React from \"react\";\n\nimport \"./InputText.scss\";\n\ninterface Props {\n  value?: string;\n  onChange?: (e: React.ChangeEvent<HTMLInputElement>) => void;\n}\n\ninterface State {}\n\nclass InputText extends React.Component<Props, State> {\n\n  render() {\n    const { value, onChange } = this.props;\n\n    return (\n      <input\n        type=\"text\"\n        className=\"InputText__input\"\n        value={value}\n        placeholder={'namespace'}\n        onChange={onChange}\n      />\n    );\n  }\n}\n\nexport default InputText;\n","import React, { Component } from \"react\";\nimport api from \"../../api\";\nimport SearchResults from \"../../components/search-results/SearchResults\";\nimport InputSearch from \"../../components/input-search/InputSearch\";\nimport ImportButton from \"../../components/import-button/ImportButton\";\nimport ExportButton from \"../../components/export-button/ExportButton\";\nimport ConfirmationButton from \"../../components/confirmation-button/ConfirmationButton\";\nimport InputText from \"../../components/input-text/InputText\";\n\nimport \"./Home.scss\";\n\nfunction leftpad(str: string | number, pad: string) {\n  return String(pad + str).slice(-pad.length);\n}\n\nfunction getDateNowString() {\n  // date\n  const d = new Date();\n\n  let ds = \"\"; // date string\n  ds += leftpad(d.getFullYear(), \"0000\") + \"-\";\n  ds += leftpad(d.getMonth(), \"00\") + \"-\";\n  ds += leftpad(d.getDate(), \"00\") + \"-\";\n  ds += leftpad(d.getHours(), \"00\");\n  ds += leftpad(d.getMinutes(), \"00\");\n  ds += leftpad(d.getSeconds(), \"00\");\n\n  return ds;\n}\n\ninterface Props { }\n\ninterface State {\n  resultText: string;\n  searchValue: string;\n  placeholderText: string;\n  terms: { namespace: string; key: string }[];\n  namespace: string;\n  flattenedTerms: string[];\n  namespaces: string[];\n}\n\nconst DEFAULT_PLACEHOLDER_TEXT = \"\";\nconst DEFAULT_NAMESPACE = \"default\";\n\nclass Home extends Component<Props, State> {\n  state: State = {\n    resultText: \"\",\n    searchValue: \"\",\n    placeholderText: DEFAULT_PLACEHOLDER_TEXT,\n    terms: [],\n    namespace: DEFAULT_NAMESPACE,\n    flattenedTerms: [],\n    namespaces: []\n  };\n\n  updateTerms(\n    searchValue: string = this.state.searchValue,\n    namespace: string = this.state.namespace\n  ) {\n    const library = api.getLibrary();\n\n    const result = library.legacy_searchTermsAndDescriptions(searchValue, namespace);\n\n    const { terms, namespaceExists, namespaces } = result;\n\n    const didNotExistBefore = !namespaces.includes(this.state.namespace);\n\n    if (\n      this.state.namespace !== \"*\" &&\n      didNotExistBefore &&\n      namespaces.includes(namespace)\n    ) {\n      this.setState({ searchValue: \"\" });\n    }\n\n    let flattenedTerms: string[];\n\n    if (namespaceExists) {\n      flattenedTerms = terms.map(term => {\n        return term.key;\n      });\n    } else {\n      flattenedTerms = terms.map(term => {\n        return `${term.namespace}: ${term.key}`;\n      });\n    }\n\n    this.setState({ terms, flattenedTerms, namespaces });\n\n    return {\n      terms,\n      flattenedTerms,\n      namespaces\n    };\n  }\n\n  resolveSearch(namespace: string, searchValue: string) {\n    const { terms } = this.updateTerms(searchValue, namespace);\n\n    const library = api.getLibrary();\n\n    const resultText = library.legacy_get(searchValue, namespace);\n\n    if (typeof resultText === \"string\") {\n      this.setState({ resultText });\n    } else if (this.state.resultText.length > 0) {\n      this.setState({ resultText: \"\" });\n    }\n\n    if (searchValue.trim().length > 0 && terms.length > 0) {\n      const key = terms[0].key;\n      const placeholderText = library.legacy_get(key, namespace);\n\n      if (placeholderText) {\n        this.setState({ placeholderText });\n      }\n    } else {\n      const { placeholderText } = this.state;\n\n      if (placeholderText !== DEFAULT_PLACEHOLDER_TEXT) {\n        this.setState({ placeholderText: DEFAULT_PLACEHOLDER_TEXT });\n      }\n    }\n\n    this.setState({ terms });\n  }\n\n  setSearchValue = (searchValue: string) => {\n    const { namespace, namespaces } = this.state;\n    this.setState({ searchValue });\n\n    if (namespaces.includes(namespace)) {\n      this.resolveSearch(namespace, searchValue);\n    } else if (namespace === \"*\") {\n      const index = searchValue.indexOf(\":\");\n      const originalSearchValue = searchValue;\n\n      if (index >= 0) {\n        // Has split\n\n        const namespace = originalSearchValue.substring(0, index).trim();\n        const searchValue = originalSearchValue\n          .substring(index + 1, originalSearchValue.length)\n          .trim();\n\n        this.resolveSearch(namespace, searchValue);\n      } else {\n        // Search everything\n        this.resolveSearch(\"*\", searchValue);\n      }\n    } else {\n      // use to pick namespace\n      // TODO: this is broken\n      // this.setNamespace(searchValue.trim());\n    }\n  };\n\n  setTermDescription(title: string, description: string) {\n    const { namespace, namespaces } = this.state;\n\n    const library = api.getLibrary();\n\n    if (namespaces.includes(namespace)) {\n      const key = title.trim().toLowerCase();\n      const value = description;\n\n      if (key.length > 0) {\n        if (value.length > 0) {\n          library.legacy_set(key, value, namespace);\n        } else {\n          library.legacy_remove(key, namespace);\n        }\n      }\n      this.updateTerms();\n    } else if (namespace === \"*\") {\n      const index = title.indexOf(\":\");\n\n      const originalTitle = title;\n\n      if (index >= 0) {\n        const namespace = originalTitle.substring(0, index).trim();\n        const title = originalTitle\n          .substring(index + 1, originalTitle.length)\n          .trimLeft();\n\n        const key = title.trim().toLowerCase();\n        const value = description;\n\n        if (key.length > 0) {\n          if (value.length > 0) {\n            library.legacy_set(key, value, namespace);\n          } else {\n            library.legacy_remove(key, namespace);\n          }\n        }\n        this.updateTerms(title, namespace);\n      }\n    } else {\n      const key = title.trim().toLowerCase();\n      const value = description;\n\n      if (key.length > 0) {\n        if (value.length > 0) {\n          library.legacy_set(key, value, namespace);\n        } else {\n          library.legacy_remove(key, namespace);\n        }\n      }\n      this.updateTerms();\n    }\n  }\n\n  setNamespace(namespace: string) {\n    const { searchValue } = this.state;\n\n    this.setState({ placeholderText: \"\" });\n\n    this.updateTerms(searchValue, namespace);\n\n    this.setState({ namespace });\n  }\n\n  forceRerender() {\n    this.setState({});\n  }\n\n  // Lifecycle methods\n\n  componentDidMount() {\n    const { searchValue, namespace } = this.state;\n    this.setSearchValue(searchValue);\n    this.setNamespace(namespace);\n  }\n\n  // Handlers\n\n  handleOnChangeTextArea = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const {\n      target: { value: resultText }\n    } = e;\n    const { searchValue, namespaces } = this.state;\n\n    const namespace = this.state.namespace.trim();\n\n    if (searchValue.trim().length > 0) {\n      if (namespaces.includes(namespace)) {\n        this.setState({\n          resultText\n        });\n\n        this.setTermDescription(searchValue, resultText);\n      } else if (namespace === \"*\") {\n        const index = searchValue.indexOf(\":\");\n\n        if (index >= 0) {\n          const right = searchValue\n            .substring(index + 1, searchValue.length)\n            .trim();\n\n          if (right.length > 0) {\n            this.setState({\n              resultText\n            });\n            this.setTermDescription(searchValue, resultText);\n          }\n        }\n      } else {\n        // CREATE NEW (???)\n        this.setTermDescription(searchValue, resultText);\n      }\n    }\n  };\n\n  handleOnSelection = (searchValue: string) => {\n    const { namespace, namespaces } = this.state;\n\n    if (namespaces.includes(namespace) || namespace.trim() === '*') {\n      this.setSearchValue(searchValue);\n    } else {\n      this.setNamespace(searchValue);\n    }\n  };\n\n  handleOnChangeSearchValue = (searchValue: string) => {\n    this.setSearchValue(searchValue);\n  };\n\n  handleOnImport = (text: string) => {\n    const library = api.getLibrary();\n\n    library.legacy_doImport(JSON.parse(text));\n    this.updateTerms();\n  };\n\n  handleOnClearEverything = () => {\n    const library = api.getLibrary();\n\n    library.removeEverything();\n    this.updateTerms();\n  };\n\n  handleGetContent = () => {\n    const library = api.getLibrary();\n\n    return JSON.stringify(library.legacy_doExport());\n  };\n\n  handleOnChangeNamespace = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const namespace = e.target.value.trim();\n\n    this.setNamespace(namespace);\n\n    if (namespace.length === 0) {\n      this.setSearchValue('');\n      this.setState({ placeholderText: '' })\n    }\n  };\n\n  autocomplete = (\n    e: React.KeyboardEvent<HTMLInputElement>,\n    value: string,\n    suggestions: string[]\n  ) => {\n    const { namespace } = this.state;\n\n    let lookupValue;\n    let derivedNamespace;\n    let derived = false;\n\n    let space1 = '';\n    let space2 = '';\n    let space3 = '';\n    let space4 = '';\n\n    if (namespace === \"*\") {\n      const index = value.indexOf(\":\");\n\n      if (index >= 0) {\n        derived = true;\n\n        const leftPart = value.substring(0, index);\n        const rightPart = value.substring(index + 1, value.length);\n\n        derivedNamespace = leftPart.trim();\n        lookupValue = rightPart.trim();\n\n        const idx1 = leftPart.indexOf(derivedNamespace);\n        const idx2 = derivedNamespace.length + idx1;\n\n        const idx3 = rightPart.indexOf(lookupValue);\n        const idx4 = lookupValue.length + idx3;\n\n\n        space1 = ' '.repeat(idx1);\n        space2 = ' '.repeat(leftPart.length - idx2);\n        space3 = ' '.repeat(idx3);\n        space4 = ' '.repeat(rightPart.length - idx4);\n\n      } else {\n        lookupValue = value;\n      }\n    } else {\n      lookupValue = value;\n    }\n\n    if (e.key === \"Enter\" || e.key === \"Tab\") {\n      if (suggestions.length > 0) {\n        const topSuggestion = suggestions[0];\n\n        if (derived) {\n          if (\n            lookupValue !== topSuggestion &&\n            topSuggestion.startsWith(lookupValue)\n          ) {\n\n            e.preventDefault();\n            return `${space1}${derivedNamespace}${space2}:${space3}${topSuggestion}${space4}`;\n          }\n        } else if (namespace === \"*\") {\n          // Degenerate case\n          e.preventDefault();\n\n          return topSuggestion;\n        } else {\n          if (\n            lookupValue !== topSuggestion &&\n            topSuggestion.startsWith(lookupValue)\n          ) {\n            e.preventDefault();\n            return topSuggestion;\n          }\n        }\n\n        if (\n          lookupValue !== topSuggestion &&\n          topSuggestion.startsWith(lookupValue)\n        ) {\n          e.preventDefault();\n\n          if (derived) {\n            return `${space1}${derivedNamespace}${space2}:${space3}${topSuggestion}${space4}`;\n          } else {\n            return topSuggestion;\n          }\n        }\n\n\n      }\n    }\n\n    return value;\n  };\n\n  render() {\n    const {\n      searchValue,\n      resultText,\n      placeholderText,\n      flattenedTerms,\n      namespace,\n      namespaces\n    } = this.state;\n\n    const ds = getDateNowString();\n    const filename = `dictionary-${ds}.json`;\n\n    let listedTerms;\n\n    if (namespaces.includes(namespace)) {\n      listedTerms = flattenedTerms;\n    } else {\n      if (namespace === \"*\") {\n        listedTerms = flattenedTerms;\n      } else {\n        listedTerms = namespaces.filter(ns =>\n          ns.startsWith(namespace)\n        );\n      }\n    }\n\n    return (\n      <div className=\"Home\">\n        <div className=\"Home__content\">\n          <div className=\"Home__top\">\n            <div className=\"Home__topLeft\">\n              <ImportButton\n                onImport={this.handleOnImport}\n                style={{ border: \"none\" }}\n              >\n                Import\n              </ImportButton>\n              <ExportButton\n                getContent={this.handleGetContent}\n                filename={filename}\n                style={{ borderTop: \"none\", borderBottom: \"none\" }}\n              >\n                Export\n              </ExportButton>\n            </div>\n            <div className=\"Home__topRight\">\n              <InputText\n                value={namespace}\n                onChange={this.handleOnChangeNamespace}\n              />\n            </div>\n          </div>\n          <div className=\"Home__center\">\n            <SearchResults\n              terms={listedTerms}\n              query={searchValue}\n              onSelection={this.handleOnSelection}\n            />\n            <div className=\"Home__main\" style={{ borderLeft: \"none\" }}>\n              <InputSearch\n                value={searchValue}\n                suggestions={listedTerms}\n                autocomplete={this.autocomplete}\n                onChange={this.handleOnChangeSearchValue}\n              />\n              <textarea\n                className=\"Home__result\"\n                onChange={this.handleOnChangeTextArea}\n                rows={20}\n                cols={50}\n                value={resultText}\n                placeholder={placeholderText}\n                spellCheck={false}\n              />\n            </div>\n          </div>\n          <div className=\"Home__bottom\">\n            <ConfirmationButton\n              onClick={this.handleOnClearEverything}\n              confirmationMessage={\n                \"Are you sure you want to delete all the terms?\"\n              }\n              style={{\n                backgroundColor: \"rgb(255, 180, 180)\",\n                color: \"rgb(180, 0, 0)\",\n                borderColor: \"rgb(255, 140, 140)\"\n              }}\n            >\n              DELETE EVERYTHING\n            </ConfirmationButton>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Home;\n","import React from 'react';\n\nimport './SystemPages.scss';\n\nexport default function NotFound() {\n  return (\n    <div className=\"system-page\">\n      NotFound\n    </div>\n  )\n};\n","import React from 'react';\nimport Helmet from 'react-helmet';\nimport { Route, Switch, withRouter } from 'react-router-dom';\n\nimport Home from './routes/home/Home';\nimport NotFound from './routes/system-pages/NotFound';\n\nimport './App.scss';\n\ntype Props = {\n  location: Location;\n};\n\nfunction App(props: Props) {\n  return (\n    <React.Fragment>\n      <Helmet defaultTitle=\"Dictionary\" />\n      <div className=\"App\">\n        <main className=\"App__main\">\n          <Switch location={props.location}>\n            <Route path=\"/\" exact component={Home} />\n            <Route component={NotFound} />\n          </Switch>\n        </main>\n      </div>\n    </React.Fragment>\n  );\n}\n\nexport default withRouter(App);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter, HashRouter } from 'react-router-dom';\n\nimport './index.scss';\nimport App from './App';\n\nReactDOM.render(\n  (\n    <HashRouter>\n      <App />\n    </HashRouter>\n  ),\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}